<!DOCTYPE html>
<html lang="cs">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width, initial-scale=1.0"/>
<title>Astronomick√° p≈ôedpovƒõƒè ‚Äì seeing (üëÅÔ∏è), v√≠tr, d√©≈°≈•</title>

<link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" crossorigin=""/>
<script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js" crossorigin=""></script>
<script src="https://cdn.jsdelivr.net/npm/astronomy-engine@2.1.0/astronomy.min.js"></script>

<link href="https://fonts.googleapis.com/css2?family=Orbitron:wght@400;600&display=swap" rel="stylesheet"/>
<style>
  :root{
    --bg:#0b0c10; --panel:#1f2833; --accent:#00ffc3; --border:#3e5363; --text:#dcdcdc; --shadow:0 0 12px rgba(0,255,195,0.5);
    --green:#00ff88; --greenFill:rgba(0,255,136,0.22);
    --red:#ff4d4d;   --redFill:rgba(255,77,77,0.22);

    /* D√©≈°≈•: svƒõtle ‚Üí tmavƒõ modr√° (dole ‚Üí naho≈ôe) */
    --rainLow:#a5d8ff;   /* svƒõtle modr√° */
    --rainHigh:#1e3a8a;  /* tmavƒõ modr√° */

    /* V√≠tr: svƒõtle ‚Üí tmavƒõ zelen√° (dole ‚Üí naho≈ôe) */
    --windLow:#c7f9cc;   /* svƒõtle mint */
    --windHigh:#03543f;  /* tmavƒõ smaragdov√° */
  }
  *{box-sizing:border-box}
  body{margin:0;background:radial-gradient(ellipse at top,#0b0c1a 0%,#1b2c3a 100%);color:var(--text);padding:16px;font-family:'Segoe UI',Tahoma,Geneva,Verdana,sans-serif}

  /* === Page layout with ad gutters === */
  .layout{
    display:grid;
    grid-template-columns: 220px minmax(300px, 1200px) 220px; /* ad-left | main | ad-right */
    gap:16px;
    align-items:start;
    justify-content:center; /* centers the middle column, keeps gutters at sides */
  }
  .ad-slot{
    position:sticky; top:16px;
    min-height:200px;
    background:rgba(0,0,0,0.15);
    border:1px dashed rgba(255,255,255,0.2);
    border-radius:12px;
    display:flex; align-items:center; justify-content:center;
    text-align:center; padding:12px; font-size:.95em; opacity:.8;
  }
  /* On narrow screens, collapse to single column and hide ad slots */
  @media (max-width: 1200px){
    .layout{ grid-template-columns: 1fr; }
    .ad-slot{ display:none; }
  }

  h1{margin:8px 0 16px;text-align:center;color:#fff;font-size:2.1rem;text-shadow:0 0 16px var(--accent)}

  /* ===== Top bar with menu + centered NOW status ===== */
  .topbar{ position:sticky; top:0; z-index:15000; /* ‚Üë Fix: topbar nad vyhled√°vaƒçem i jeho n√°vrhy */
    display:grid; grid-template-columns:auto 1fr auto; align-items:center;
    padding:8px 10px;
    background:linear-gradient(180deg, rgba(11,12,16,0.92) 0%, rgba(11,12,16,0.70) 100%);
    border:1px solid rgba(255,255,255,0.08);
    border-radius:12px;
    backdrop-filter:saturate(140%) blur(6px);
    box-shadow:0 6px 18px rgba(0,0,0,.35);
  }
  .menu-container{position:relative;align-self:flex-start; z-index:9000}
  .menu-toggle{background:var(--accent);color:#000;font-weight:bold;padding:8px 14px;border-radius:10px;cursor:pointer;border:none;box-shadow:var(--shadow)}
  .menu-dropdown{display:none;position:absolute;top:110%;left:0;background:var(--panel);border:1px solid var(--border);border-radius:10px;min-width:240px;box-shadow:0 8px 16px rgba(0,0,0,.6);overflow:visible; z-index:9500}
  .menu-section{padding:6px 0;position:relative;border-bottom:1px solid rgba(255,255,255,.06)}
  .menu-section:last-child{border-bottom:none}
  .menu-item,.menu-link{display:flex;justify-content:space-between;align-items:center;gap:8px;padding:10px 16px;color:var(--accent);text-decoration:none;cursor:pointer;white-space:nowrap}
  .menu-item:hover,.menu-link:hover{background:#2e8b57;color:#fff}
  .submenu{display:none;position:absolute;top:0;left:100%;background:var(--panel);border:1px solid var(--border);border-radius:10px;min-width:230px;box-shadow:0 8px 16px rgba(0,0,0,.6); z-index:9600;}
  .has-submenu{position:relative}
  .has-submenu:hover>.submenu{display:block}

  .now-status{
    justify-self:center; /* center in grid middle column */
    display:flex; align-items:center; gap:10px;
    padding:6px 12px; border-radius:999px;
    border:1px solid var(--border);
    background:rgba(0,0,0,.35);
    box-shadow:0 2px 10px rgba(0,0,0,.35);
    font-weight:700;
  }
  .now-status .place{opacity:.9; font-weight:600; margin-right:4px}
  .now-status .sep{opacity:.4}
  .now-status .val{min-width:50px; text-align:center}

  /* ===== Diagnostics modal ===== */
  .modal-overlay{
    position:fixed; inset:0; background:rgba(0,0,0,0.6);
    display:none; align-items:center; justify-content:center; z-index:3000;
  }
  .modal{
    width:min(760px, 92vw); max-height:80vh; overflow:auto;
    background:var(--panel); border:1px solid var(--border); border-radius:14px;
    box-shadow:0 0 20px rgba(0,0,0,.6); padding:14px;
  }
  .modal header{display:flex; align-items:center; justify-content:space-between; gap:8px; margin-bottom:8px}
  .modal header h2{margin:0; font-size:1.25rem}
  .close-btn{background:none; color:#fff; border:1px solid var(--border); border-radius:8px; padding:6px 10px; cursor:pointer}
  .diag-item{display:flex;align-items:center;justify-content:space-between;gap:8px;padding:6px 0;border-bottom:1px solid rgba(255,255,255,.06)}
  .diag-item:last-child{border-bottom:none}
  .diag-name{opacity:.9}
  .diag-status{font-weight:700}
  .ok{color:#00ff88} .fail{color:#ff6b6b} .pending{color:#ffd166}
  .tiny{font-size:.85em;opacity:.8}

  /* ===== Controls + layout ===== */
  .controls{display:flex;justify-content:center;align-items:center;gap:8px;flex-wrap:wrap;margin:12px 0}
  .input-wrapper{position:relative; z-index:4000}
  #cityInput{width:360px;max-width:100%;padding:10px 36px 10px 12px;border-radius:10px;border:2px solid var(--accent);background:#111;color:#00ffc3;font-weight:700;box-shadow:var(--shadow)}
  .btn{background:#7a6cb6;color:#fff;border:none;border-radius:10px;padding:10px 14px;font-weight:700;cursor:pointer;box-shadow:0 0 10px rgba(122,108,182,.5)}
  #suggestions{position:absolute;top:100%;left:0;right:0;background:#121212;border:1px solid var(--border);border-radius:10px;list-style:none;padding:0;margin:6px 0 0 0;display:none;overflow:hidden;z-index:5000}
  #suggestions li{padding:10px 12px;cursor:pointer;color:var(--text)} #suggestions li:hover{background:#243442}

  .top-row{display:grid;grid-template-columns: minmax(300px, 1fr) minmax(280px, 1fr);gap:16px;align-items:start}
  .left-col{display:flex;flex-direction:column;gap:16px}
  .right-col{position:relative}

  .panel{background:var(--panel);border:1px solid var(--border);border-radius:12px;padding:14px;box-shadow:0 2px 12px rgba(0,0,0,.5)}
  .panel strong{color:var(--accent)}
  .kv{display:grid;grid-template-columns:max-content 1fr;gap:6px 10px}

  #mapPanel{padding:0;overflow:hidden;position:relative; z-index:1}
  #map{width:100%;height:100%}
  .zoom-badge{position:absolute;top:8px;left:8px;background:rgba(0,0,0,0.55);color:#fff;padding:4px 8px;border-radius:999px;font-size:.85em;border:1px solid rgba(255,255,255,.2);z-index:2}
  .map-tip{position:absolute;bottom:8px;left:8px;background:rgba(0,0,0,0.55);color:#fff;padding:6px 8px;border-radius:8px;font-size:.9em;border:1px solid rgba(255,255,255,.2);z-index:2}

  .forecast-day{border:1px solid var(--border);border-radius:10px;overflow:hidden;position:relative}
  .forecast-day h3{margin:0;padding:10px;background:#4b3f72;color:#fff;display:flex;align-items:center;gap:8px;cursor:pointer;position:relative;z-index:2;flex-wrap:wrap}
  .mode-tabs{display:flex; gap:6px; margin-left:auto}
  .mode-btn{
    background:rgba(255,255,255,0.1); color:#fff; border:1px solid rgba(255,255,255,0.2);
    border-radius:999px; padding:4px 10px; cursor:pointer; font-weight:700; font-size:.9em
  }
  .mode-btn.active{background:var(--accent); color:#000; box-shadow:0 0 10px rgba(0,255,195,.5)}
  .mode-btn:hover{filter:brightness(1.1)}
  .tiny-help{font-size:.85em;opacity:.85;margin-left:6px}

  .forecast-content{display:none;padding:10px;position:relative}
  .forecast-scroll-wrapper{position:relative; overflow:hidden;} /* prevent vertical scrollbars */
  .forecast-scroll{position:relative;display:flex;gap:8px;overflow-x:auto; overflow-y:hidden; padding:6px 0;z-index:2} /* hide vertical scroll */
  .bg-graph{position:absolute;top:0;left:0;z-index:1;pointer-events:none;}
  .forecast-card{min-width:80px;font-size:.9em;background:rgba(44,47,51,0.72);border:1px solid var(--border);border-radius:8px;padding:6px;text-align:center;position:relative;z-index:2}
  .scroll-left,.scroll-right{background:none;border:none;color:#fff;font-size:1.5em;padding:6px 10px;cursor:pointer;position:absolute;top:50%;transform:translateY(-50%);opacity:.6;text-shadow:0 0 6px rgba(255,255,255,.3);z-index:3}
  .scroll-left{left:6px}.scroll-right{right:6px}
  .spinner{display:none;width:44px;height:44px;margin:8px auto;border:6px solid #333;border-top:6px solid var(--accent);border-radius:50%;animation:spin 1s linear infinite}
  @keyframes spin{100%{transform:rotate(360deg)}}
  .footer{text-align:center;opacity:.8;margin-top:10px;font-size:.95em}
  .small{font-size:.92em;opacity:.9}
  .pill{display:inline-block;padding:2px 8px;border-radius:999px;background:#243442;border:1px solid var(--border);margin:4px 6px 0 0}


/* === Mobile-first vylep≈°en√≠ (‚â§ 768px) === */
@media (max-width: 768px){
  :root{
    --safe-top: env(safe-area-inset-top);
    --safe-bottom: env(safe-area-inset-bottom);
  }

  body{ padding:8px; padding-bottom: calc(12px + var(--safe-bottom)); }
  h1{ font-size:1.5rem; margin:6px 0 10px; }

  .topbar{
    padding:6px 8px;
    padding-top: calc(6px + var(--safe-top));
    gap:6px;
    grid-template-columns:auto 1fr auto;
  }
  .now-status{
    flex-wrap:wrap;
    row-gap:4px;
    font-size:.95em;
  }

  .controls{ gap:6px; }
  #cityInput{
    width:100%;
    font-size:16px;
    padding:12px 38px 12px 12px;
  }
  #suggestions{ max-height:50vh; overflow:auto; }

  .top-row{ grid-template-columns: 1fr; }
  .panel{ padding:12px; }

  #mapPanel{ height:48vh !important; }
  #map{ height:48vh !important; }

  .forecast-scroll{
    -webkit-overflow-scrolling: touch;
    padding-bottom:10px;
  }
  .forecast-card{ min-width:96px; padding:8px; }
  .scroll-left, .scroll-right{ display:none; }

  .mode-tabs{ flex-wrap:wrap; }
}
</style>
</head>
<body>

<div class="layout">
  <!-- Left ad gutter -->
  <aside class="ad-slot">Rezervov√°no pro lev√Ω banner (220px)</aside>

  <!-- Main column -->
  <main>
    <div class="topbar">
      <div class="menu-container">
        <button class="menu-toggle" onclick="toggleMenu()">üìã Menu</button>
        <div class="menu-dropdown" id="mainMenu">
          <div class="menu-section">
            <div class="menu-item has-submenu">üó∫Ô∏è Mapy ‚ñ∏
              <div class="submenu">
                <a class="menu-link" href="https://www.lightpollutionmap.info" target="_blank">üí° Light Pollution Map</a>
                <a class="menu-link" href="https://www.windy.com" target="_blank">üå¨Ô∏è Windy</a>
              </div>
            </div>
          </div>
          <div class="menu-section">
            <div class="menu-item has-submenu">üõ†Ô∏è N√°stroje ‚ñ∏
              <div class="submenu">
                <a class="menu-link" href="#" id="openDiag">üß™ API diagnostika</a>
              </div>
            </div>
          </div>
          <!-- NOVƒö: Verze v menu s hover zobrazen√≠m -->
          <div class="menu-section">
            <div class="menu-item has-submenu">‚ÑπÔ∏è Verze ‚ñ∏
              <div class="submenu">
                <div class="menu-item" id="versionInMenuRow">Aktu√°ln√≠: <strong id="versionInMenu">‚Äî</strong></div>
              </div>
            </div>
          </div>
        </div>
      </div>

      <!-- Prost≈ôedn√≠ (center) bu≈àka gridu: NOW status -->
      <div id="nowStatus" class="now-status" style="display:none">
        <span class="place" id="nowPlace">‚Äî</span><span class="sep">|</span>
        <span>üëÅÔ∏è <span class="val" id="nowSeeing">‚Äî</span></span>
        <span class="sep">‚Ä¢</span>
        <span>üí® <span class="val" id="nowWind">‚Äî</span></span>
        <span class="sep">‚Ä¢</span>
        <span>üåßÔ∏è <span class="val" id="nowRain">‚Äî</span></span>
        <span class="sep">‚Ä¢</span>
        <span>üå°Ô∏è <span class="val" id="nowTemp">‚Äî</span></span>
      </div>

      <!-- Prav√° (t≈ôet√≠) bu≈àka gridu pr√°zdn√° pro symetrii -->
      <div></div>
    </div>

    <h1>ü™ê Astronomick√° p≈ôedpovƒõƒè</h1>

    <div class="controls">
      <div class="input-wrapper">
        <input id="cityInput" type="text" placeholder="Zadejte mƒõsto..." oninput="autocompleteCities()"/>
        <ul id="suggestions"></ul>
      </div>
      <button class="btn" onclick="getLocation()">üìç Moje poloha</button>
    </div>

    <div class="top-row">
      <div class="left-col" id="leftTop">
        <div class="panel">
          <strong>üìç Informace o m√≠stƒõ</strong>
          <div class="kv" style="margin-top:8px;">
            <span><strong>N√°zev:</strong></span><span id="info-name">‚Äî</span>
            <span><strong>GPS:</strong></span><span id="info-gps">‚Äî</span>
            <span><strong>Mapa LP:</strong></span><span><a id="bortle-link" href="#" target="_blank" style="display:none;color:#00ffc3;text-decoration:underline;font-weight:bold;">Zobrazit Bortle</a></span>
          </div>
        </div>

        <div class="panel">
          <strong>üî≠ Astronomick√© informace</strong>
          <div style="margin-top:8px;">
            <div><strong>üåô F√°ze Mƒõs√≠ce:</strong> <span id="moon-phase-label">‚Äî</span></div>
          </div>
          <div style="margin-top:12px;">
            <div style="display:flex;align-items:center;gap:8px;">
              <strong>ü™ê Viditeln√© planety ~22:00</strong>
              <span id="planet-log" class="small" style="opacity:.85;"></span>
            </div>
            <div id="planets-list"></div>
          </div>
        </div>
      </div>

      <div class="right-col">
        <div class="panel" id="mapPanel">
          <div id="map"></div>
          <div id="mapZoomBadge" class="zoom-badge">Zoom: vypnuto</div>
          <div class="map-tip">Klikni <b>prav√Ωm</b> na mapu pro zapnut√≠/vypnut√≠ zoomu</div>
        </div>
      </div>
    </div>

    <div class="spinner" id="spinner" style="margin-top:16px;"></div>
    <div id="forecast" style="margin-top:8px;"></div>

    <div class="footer">
      Zdroj f√°z√≠: ipgeolocation.io ‚Ä¢ Poƒças√≠ a geok√≥dov√°n√≠: Open-Meteo ‚Ä¢ Planety: Astronomy Engine (fallback ipgeolocation) ‚Ä¢ Mapa: Leaflet & OSM
    </div>
  </main>

  <!-- Right ad gutter -->
  <aside class="ad-slot">Rezervov√°no pro prav√Ω banner (220px)</aside>
</div>

<!-- Diagnostics modal -->
<div class="modal-overlay" id="diagOverlay" role="dialog" aria-modal="true" aria-labelledby="diagTitle">
  <div class="modal">
    <header>
      <h2 id="diagTitle">üß™ API diagnostika</h2>
      <div>
        <button class="btn" id="rerunDiag" title="Spustit znovu">Spustit znovu</button>
        <button class="close-btn" id="closeDiag">Zav≈ô√≠t</button>
      </div>
    </header>
    <div class="tiny" style="margin-bottom:6px;">P≈ôi otev≈ôen√≠ se spust√≠ test, tlaƒç√≠tkem ‚ÄûSpustit znovu‚Äú lze opakovat.</div>
    <div id="diagList"></div>
  </div>
</div>

<script>
const IPGEO_API_KEY="781aa2d69af74745906e01cc68c84207";
const VERSION = "v0.3.8";

/* ===== Menu ===== */
function toggleMenu(){const m=document.getElementById("mainMenu");m.style.display=m.style.display==="block"?"none":"block"}
document.addEventListener("click",(e)=>{const m=document.getElementById("mainMenu");const t=document.querySelector(".menu-toggle");if(m&&t&&!m.contains(e.target)&&!t.contains(e.target))m.style.display="none"});

/* Po naƒçten√≠: doplnit verzi do menu + tooltip na tlaƒç√≠tko */
window.addEventListener('DOMContentLoaded', ()=>{
  const vSpan = document.getElementById('versionInMenu');
  if(vSpan) vSpan.textContent = VERSION;
  const btn = document.querySelector('.menu-toggle');
  if(btn) btn.title = `Verze ${VERSION}`;
});

/* ===== Helpers ===== */
const $=(id)=>document.getElementById(id);
function showSpinner(b){$("spinner").style.display=b?"block":"none"}
function getDayName(d){const today=new Date().toLocaleDateString('en-CA',{timeZone:'Europe/Prague'});if(d===today)return"Dnes";const arr=['Nedƒõle','Pondƒõl√≠','√öter√Ω','St≈ôeda','ƒåtvrtek','P√°tek','Sobota'];return arr[new Date(d+'T00:00:00').getDay()]}
function getWeatherIcon(c,r){
  if(r>2)return'üåßÔ∏è';
  if(r>0)return'üå¶Ô∏è';
  if(c>75)return'‚òÅÔ∏è';
  if(c>25)return'üå§Ô∏è';
  return'‚òÄÔ∏è';
}

/* ===== Layout sync ===== */
function syncMapHeight(){
  const left=document.getElementById("leftTop");
  const mapPanel=document.getElementById("mapPanel");
  const mapDiv=document.getElementById("map");
  if(!left||!mapPanel||!mapDiv) return;
  const h=left.getBoundingClientRect().height;
  mapPanel.style.height=h+"px";
  mapDiv.style.height=h+"px";
  if(window._leafletMap){ setTimeout(()=> window._leafletMap.invalidateSize(), 100); }
}
const leftObserver = new MutationObserver(()=> syncMapHeight());
leftObserver.observe(document.getElementById("leftTop"), {subtree:true, childList:true, characterData:true});
window.addEventListener("resize", syncMapHeight);

/* ===== Geocoding & selection ===== */
let selectedCity=null;
async function autocompleteCities(){const v=$("cityInput").value.trim();const s=$("suggestions");if(v.length<2){s.style.display="none";return}const res=await fetch(`https://geocoding-api.open-meteo.com/v1/search?name=${encodeURIComponent(v)}&count=6&language=cs&format=json`);const data=await res.json();s.innerHTML="";(data.results||[]).forEach(c=>{const li=document.createElement("li");li.textContent=`${c.name}, ${c.country}`;li.onclick=()=>{selectedCity=c;$("cityInput").value=`${c.name}, ${c.country}`;updateLocationInfo(c);initMap(c.latitude,c.longitude);fetchForecast(c.latitude,c.longitude);fetchMoonPhase(c.latitude,c.longitude);fetchPlanets(c.latitude,c.longitude);s.style.display="none"};s.appendChild(li)});s.style.display=s.children.length?"block":"none"}

async function getLocation(){
  if(!navigator.geolocation)return alert("V√°≈° prohl√≠≈æeƒç nepodporuje geolokaci.");
  navigator.geolocation.getCurrentPosition(async p=>{
    const lat=p.coords.latitude,lon=p.coords.longitude;
    const name=await reverseGeocode(lat,lon);
    const c={name,country:"",latitude:lat,longitude:lon};
    selectedCity=c;
    updateLocationInfo(c);
    initMap(lat,lon);
    fetchForecast(lat,lon);
    fetchMoonPhase(lat,lon);
    fetchPlanets(lat,lon);
    /* NOVƒö: po kliknut√≠ na Moje poloha vyƒçistit vstup i n√°vrhy */
    const input=$("cityInput"); if(input) input.value="";
    const s=$("suggestions"); if(s) { s.innerHTML=""; s.style.display="none"; }
  },e=>alert("Nepoda≈ôilo se zjistit polohu."));
}

async function reverseGeocode(lat,lon){try{const r=await fetch(`https://nominatim.openstreetmap.org/reverse?format=json&lat=${lat}&lon=${lon}&zoom=10&addressdetails=1`);const d=await r.json();return d.address?.city||d.address?.town||d.address?.village||d.address?.municipality||d.display_name||`${lat.toFixed(4)}, ${lon.toFixed(4)}`}catch{return `${lat.toFixed(4)}, ${lon.toFixed(4)}`}} 

function updateLocationInfo(c){const name=c.name||"-";const country=c.country||"";const lat=typeof c.latitude==="number"?c.latitude:null;const lon=typeof c.longitude==="number"?c.longitude:null;$("info-name").innerHTML=country?`<span style="color:#00ffc3;font-weight:bold;">${name}</span>, ${country}`:`<span style="color:#00ffc3;font-weight:bold;">${name}</span>`;$("info-gps").textContent=(lat!=null&&lon!=null)?`${lat.toFixed(4)}, ${lon.toFixed(4)}`:"‚Äî";const link=$("bortle-link");if(lat!=null&&lon!=null){link.href=`https://www.lightpollutionmap.info/#zoom=9&lat=${lat}&lon=${lon}`;link.style.display="inline"}else{link.style.display="none"};const np=$("nowPlace");if(np){np.textContent = name || "‚Äî";}}

/* ===== Map on the right ===== */
let map=null,marker=null,zoomEnabled=false,zoomControl=null;
function initMap(lat,lon){
  syncMapHeight();
  if(!map){
    map=window._leafletMap = L.map('map', { zoomControl:false, scrollWheelZoom:false, touchZoom:false, doubleClickZoom:false, boxZoom:false, keyboard:false, dragging:true }).setView([lat,lon],10);
    L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png',{maxZoom:19,attribution:'¬© OpenStreetMap'}).addTo(map);
    marker=L.marker([lat,lon]).addTo(map);
    map.on('contextmenu', function(){
      zoomEnabled = !zoomEnabled;
      const badge = $("mapZoomBadge");
      if(zoomEnabled){
        map.scrollWheelZoom.enable(); map.touchZoom.enable(); map.doubleClickZoom.enable(); map.boxZoom.enable(); map.keyboard.enable();
        if(!zoomControl){ zoomControl = L.control.zoom({position:'topleft'}).addTo(map); }
        if(badge) badge.textContent = "Zoom: zapnuto";
      } else {
        map.scrollWheelZoom.disable(); map.touchZoom.disable(); map.doubleClickZoom.disable(); map.boxZoom.disable(); map.keyboard.disable();
        if(zoomControl){ map.removeControl(zoomControl); zoomControl=null; }
        if(badge) badge.textContent = "Zoom: vypnuto";
      }
    });
  } else {
    map.setView([lat,lon], 10);
    marker.setLatLng([lat,lon]);
  }
  // initialize RainViewer overlays once when map is ready
  enableWeatherLayers();
  setTimeout(()=> { map.invalidateSize(); syncMapHeight(); }, 150);
}

/* ===== Moon phase (ipgeolocation only) ===== */
let moonIllumByDate = {};
function getMoonEmojiFromName(n){n=String(n||"").toLowerCase().replace(/_/g," ").trim();if(n.includes("new moon"))return"üåë Nov";if(n.includes("waxing crescent"))return"üåí Dor≈Østaj√≠c√≠ srpek";if(n.includes("first quarter"))return"üåì Prvn√≠ ƒçtvr≈•";if(n.includes("waxing gibbous"))return"üåî Dor≈Østaj√≠c√≠ mƒõs√≠c";if(n.includes("full moon"))return"üåï √öplnƒõk";if(n.includes("waning gibbous"))return"üåñ Couvaj√≠c√≠ mƒõs√≠c";if(n.includes("last quarter"))return"üåó Posledn√≠ ƒçtvr≈•";if(n.includes("waning crescent"))return"üåò Couvaj√≠c√≠ srpek";return"üåô Nezn√°m√° f√°ze"}
async function fetchMoonPhase(lat,lon){
  const url=`https://api.ipgeolocation.io/astronomy?apiKey=${IPGEO_API_KEY}&lat=${lat}&long=${lon}`;
  try{
    const r=await fetch(url);
    const d=await r.json();
    const p=d.moon_phase||"Nezn√°m√° f√°ze";
    $("moon-phase-label").textContent=getMoonEmojiFromName(p);
    const today = new Date().toLocaleDateString('en-CA', { timeZone: 'Europe/Prague' });
    const illumPct = Number(d.moon_illumination);
    if(Number.isFinite(illumPct)){
      moonIllumByDate[today] = Math.max(0, Math.min(1, illumPct/100));
    }
  }catch(e){
    console.error("Chyba p≈ôi naƒç√≠t√°n√≠ f√°ze:",e);
    $("moon-phase-label").textContent="Chyba naƒç√≠t√°n√≠";
  }
}

/* ===== Star visibility score (pro seeing re≈æim) ===== */
function visibilityScore(cloud, precip, dateStr){
  const cloudScore = 100 - Math.min(Math.max(cloud,0),100);
  const rainPenalty = Math.min(precip*50, 50);
  const illum = moonIllumByDate[dateStr] ?? 0;  // 0..1
  const moonPenalty = illum * 40;
  const raw = cloudScore - rainPenalty - moonPenalty;
  return Math.max(0, Math.min(100, Math.round(raw)));
}

/* Compute exact width of cards */
function measureCardsWidth(scrollEl){
  const cards = scrollEl.querySelectorAll('.forecast-card');
  if(cards.length === 0) return 0;
  const style = getComputedStyle(scrollEl);
  const gap = parseFloat(style.columnGap || style.gap || 0) || 0;
  let sum = 0;
  cards.forEach((c)=>{ sum += c.getBoundingClientRect().width; });
  sum += gap * (cards.length - 1);
  return Math.ceil(sum);
}

/* ===== Scaling ===== */
const RAIN_MAX_MM = 5;     // 0..5 mm/h => 100 %
const WIND_MAX_KMH = 50;   // 0..50 km/h => 100 %

/* ===== Mode score (0..100) ===== */
function scoreForMode(entry, mode, dateStr){
  if(mode === 'seeing'){ // d≈ô√≠ve 'cloud'
    return Math.max(0, Math.min(100, 100 - (entry.cloud ?? 0)));
  }
  if(mode === 'wind'){
    const w = Math.max(0, Math.min(WIND_MAX_KMH, entry.wind ?? 0));
    return Math.round(100 * (w / WIND_MAX_KMH)); // 0..100 (v√≠c vƒõtru = v√Ω≈°)
  }
  if(mode === 'rain'){
    const r = Math.max(0, Math.min(RAIN_MAX_MM, entry.rain ?? 0));
    return Math.round(100 * (r / RAIN_MAX_MM)); // 0..100 (v√≠c sr√°≈æek = v√Ω≈°)
  }
  // fallback: seeing
  return visibilityScore(entry.cloud ?? 0, entry.rain ?? 0, dateStr);
}

/* ===== Graph drawing ===== */
function drawBackgroundGraph(scrollEl, entries, dateStr, mode='seeing'){
  const old = scrollEl.querySelector('.bg-graph');
  if(old) old.remove();

  let totalW = measureCardsWidth(scrollEl);
  if(!Number.isFinite(totalW) || totalW <= 0) totalW = Math.max(1, scrollEl.scrollWidth);

  const totalH = scrollEl.getBoundingClientRect().height || 140;

  const svgNS="http://www.w3.org/2000/svg";
  const wrap = document.createElement('div');
  wrap.className = "bg-graph";
  wrap.style.width = totalW + "px";
  wrap.style.height = totalH + "px";

  const svg = document.createElementNS(svgNS, 'svg');
  svg.setAttribute('width', totalW);
  svg.setAttribute('height', totalH);
  svg.style.display='block';

  const defs = document.createElementNS(svgNS,'defs');
  const mkGrad = (id, lowVar, highVar) => {
    const lg = document.createElementNS(svgNS,'linearGradient');
    lg.setAttribute('id', id);
    lg.setAttribute('x1','0'); lg.setAttribute('y1','1');
    lg.setAttribute('x2','0'); lg.setAttribute('y2','0');
    const stop1 = document.createElementNS(svgNS,'stop');
    stop1.setAttribute('offset','0%');  stop1.setAttribute('stop-color', getComputedStyle(document.documentElement).getPropertyValue(lowVar).trim() || 'white');
    const stop2 = document.createElementNS(svgNS,'stop');
    stop2.setAttribute('offset','100%');stop2.setAttribute('stop-color', getComputedStyle(document.documentElement).getPropertyValue(highVar).trim() || 'black');
    lg.appendChild(stop1); lg.appendChild(stop2);
    return lg;
  };
  defs.appendChild(mkGrad('rainGrad','--rainLow','--rainHigh'));
  defs.appendChild(mkGrad('windGrad','--windLow','--windHigh'));
  svg.appendChild(defs);

  if(mode === 'seeing'){
    const midY = totalH/2;
    const amp = (totalH/2) * 0.9;

    const baseline = document.createElementNS(svgNS, 'line');
    baseline.setAttribute('x1', 0); baseline.setAttribute('y1', midY);
    baseline.setAttribute('x2', totalW); baseline.setAttribute('y2', midY);
    baseline.setAttribute('stroke', 'rgba(255,255,255,0.2)');
    baseline.setAttribute('stroke-width', '1');
    svg.appendChild(baseline);

    const n = entries.length;
    if(n<2){ wrap.appendChild(svg); scrollEl.insertAdjacentElement('afterbegin', wrap); return; }

    const points = [];
    for(let i=0;i<n;i++){
      const x = (totalW-1) * (i/(n-1));
      const score = scoreForMode(entries[i], 'seeing', dateStr);
      const norm = score - 50; // -50..+50
      const y = midY - (norm/50)*amp;
      points.push([x,y]);
    }

    const makeAreaPath = (clampFn, fill) => {
      const dTop = points.map(([x,y],i)=> (i===0 ? `M ${x} ${clampFn(y)}` : `L ${x} ${clampFn(y)}`)).join(' ');
      const d = `${dTop} L ${points[n-1][0]} ${midY} L ${points[0][0]} ${midY} Z`
      const p = document.createElementNS(svgNS, 'path');
      p.setAttribute('d', d);
      p.setAttribute('fill', fill);
      p.setAttribute('stroke', 'transparent');
      return p;
    };
    svg.appendChild(makeAreaPath(y => Math.min(y, midY), 'var(--greenFill)'));
    svg.appendChild(makeAreaPath(y => Math.max(y, midY), 'var(--redFill)'));

    const linePath = document.createElementNS(svgNS, 'path');
    const dLine = points.map(([x,y],i)=> (i===0 ? `M ${x} ${y}` : `L ${x} ${y}`)).join(' ');
    linePath.setAttribute('d', dLine);
    linePath.setAttribute('fill', 'none');
    linePath.setAttribute('stroke', 'rgba(255,255,255,0.6)');
    linePath.setAttribute('stroke-width', '1.6');
    svg.appendChild(linePath);
  } else {
    const baseY = totalH - 2;
    const topPad = 6;
    const usableH = Math.max(20, baseY - topPad);

    const baseLine = document.createElementNS(svgNS,'line');
    baseLine.setAttribute('x1',0); baseLine.setAttribute('y1',baseY);
    baseLine.setAttribute('x2',totalW); baseLine.setAttribute('y2',baseY);
    baseLine.setAttribute('stroke','rgba(255,255,255,.18)');
    svg.appendChild(baseLine);

    const n = entries.length;
    if(n<2){ wrap.appendChild(svg); scrollEl.insertAdjacentElement('afterbegin', wrap); return; }

    const points=[];
    for(let i=0;i<n;i++){
      const x=(totalW-1)*(i/(n-1));
      const score=scoreForMode(entries[i], mode, dateStr);
      const y= baseY - (score/100)*usableH;
      points.push([x,y]);
    }

    const dTop = points.map(([x,y],i)=> (i?`L ${x} ${y}`:`M ${x} ${y}`)).join(' ');
    const dArea = `${dTop} L ${points[n-1][0]} ${baseY} L ${points[0][0]} ${baseY} Z`;
    const area = document.createElementNS(svgNS,'path');
    area.setAttribute('d', dArea);
    area.setAttribute('fill', mode==='rain' ? 'url(#rainGrad)' : 'url(#windGrad)');
    area.setAttribute('stroke','none');
    svg.appendChild(area);

    const line=document.createElementNS(svgNS,'path');
    const dLine = points.map(([x,y],i)=> (i?`L ${x} ${y}`:`M ${x} ${y}`)).join(' ');
    line.setAttribute('d', dLine);
    line.setAttribute('fill','none');
    line.setAttribute('stroke', mode==='rain'
      ? getComputedStyle(document.documentElement).getPropertyValue('--rainHigh').trim() || '#1e3a8a'
      : getComputedStyle(document.documentElement).getPropertyValue('--windHigh').trim() || '#03543f'
    );
    line.setAttribute('stroke-width','1.8');
    svg.appendChild(line);
  }

  wrap.appendChild(svg);
  scrollEl.insertBefore(wrap, scrollEl.firstChild);
}

/* ===== Forecast ===== */
window._graphData = {};
window._graphMode = {};

function updateNowStatusFromArrays(timeArr, tempArr, cloudArr, rainArr, windArr){
  if(!(timeArr && timeArr.length)) return;
  try{
    const nowDate = new Date();
    const tz = 'Europe/Prague';
    const y = nowDate.toLocaleString('en-CA', { timeZone: tz, year:'numeric' });
    const m = nowDate.toLocaleString('en-CA', { timeZone: tz, month:'2-digit' });
    const d = nowDate.toLocaleString('en-CA', { timeZone: tz, day:'2-digit' });
    const hh = nowDate.toLocaleString('en-GB', { timeZone: tz, hour:'2-digit', hour12:false });
    const target = `${y}-${m}-${d}T${hh}:00`;
    let idx = timeArr.indexOf(target);
    if(idx < 0){ // pick next closest hour in future, else last
      idx = timeArr.findIndex(t => t >= target);
      if(idx < 0) idx = timeArr.length - 1;
    }
    const [dateStr] = timeArr[idx].split('T');
    const temp = Math.round(tempArr[idx]);
    const cloud = cloudArr[idx];
    const rain = rainArr[idx];
    const wind = Math.round(windArr[idx]);
    const seeing = visibilityScore(cloud, rain, dateStr);
    $("nowTemp").textContent = `${temp}¬∞C`;
    $("nowWind").textContent = `${wind} km/h`;
    $("nowRain").textContent = `${rain} mm/h`;
    $("nowSeeing").textContent = `${seeing}/100`;
    $("nowStatus").style.display = "flex";
  }catch(e){ console.warn("NOW status update failed", e); }
}

async function fetchForecast(lat,lon){
  showSpinner(true);
  const r=await fetch(`https://api.open-meteo.com/v1/forecast?latitude=${lat}&longitude=${lon}&hourly=temperature_2m,cloudcover,precipitation,windspeed_10m&timezone=Europe/Prague`);
  const d=await r.json();
  showSpinner(false);
  const {time,temperature_2m,cloudcover,precipitation,windspeed_10m}=d.hourly;

  // Update topbar NOW status
  updateNowStatusFromArrays(time, temperature_2m, cloudcover, precipitation, windspeed_10m);

  const div=$("forecast");div.innerHTML="";
  const days={};
  
  for(let i=0;i<time.length;i++){
    let [date,hour] = time[i].split('T');
    if(hour === '24:00'){
      const dt = new Date(date + 'T00:00:00');
      const next = new Date(dt.getTime() + 24*60*60*1000);
      const y = next.getFullYear();
      const m = String(next.getMonth()+1).padStart(2,'0');
      const d2 = String(next.getDate()).padStart(2,'0');
      date = `${y}-${m}-${d2}`;
      hour = '00:00';
    }
    const entry={time:hour,temp:temperature_2m[i],cloud:cloudcover[i],rain:precipitation[i],wind:windspeed_10m[i],date};
    if(!days[date]) days[date]=[];
    if(time[i].startsWith(date+'T')){
      days[date].push(entry);
    }
  }

  let idx=0;
  Object.entries(days).sort((a,b)=> a[0]<b[0]? -1 : a[0]>b[0]? 1 : 0).forEach(([date,entries])=>{
    if(!entries.length) return;
    try{
      const todayLocal = new Date().toLocaleDateString('en-CA', { timeZone: 'Europe/Prague' });
      if(date === todayLocal){
        const nowHHmm = new Date().toLocaleTimeString('en-GB', { hour: '2-digit', minute: '2-digit', hour12: false, timeZone: 'Europe/Prague' });
        entries = entries.filter(e => e.time >= nowHHmm);
      }
    }catch(e){/* noop */}

    const section=document.createElement('div'); section.className='forecast-day';
    const header=document.createElement('h3'); const contentId=`day-${idx++}`;
    header.dataset.date=date;

    const leftPart = document.createElement('div');
    leftPart.style.display='flex'; leftPart.style.alignItems='center'; leftPart.style.gap='8px';
    leftPart.innerHTML = `<span id="${contentId}-icon">‚¨ÜÔ∏è</span> ${getDayName(date)}, ${date}
      <button class="btn" style="padding:4px 8px;font-size:.85em" onclick="event.stopPropagation(); goToStart('${contentId}')">R√°no</button>
      <button class="btn" style="padding:4px 8px;font-size:.85em" onclick="event.stopPropagation(); centerTime('${contentId}', '12:00')">Poledne</button>
      <button class="btn" style="padding:4px 8px;font-size:.85em" onclick="event.stopPropagation(); centerTime('${contentId}', '23:00')">P≈Ølnoc</button>
      <span class="tiny-help">(Kliknut√≠m na den sbal√≠≈°/rozbal√≠≈°)</span>`;

    const tabs = document.createElement('div');
    tabs.className='mode-tabs';
    tabs.innerHTML = `
      <button class="mode-btn active" data-mode="seeing" title="Seeing (lep≈°√≠ ‚Üë)">üëÅÔ∏è</button>
      <button class="mode-btn" data-mode="wind" title="V√≠tr (svƒõtl√° ‚Üì ‚Üí tmav√° ‚Üë)">üí®</button>
      <button class="mode-btn" data-mode="rain" title="D√©≈°≈• (svƒõtl√° ‚Üì ‚Üí tmav√° ‚Üë)">üåßÔ∏è</button>`;
    tabs.addEventListener('click', (e)=>{
      if(!(e.target instanceof HTMLElement)) return;
      const btn = e.target.closest('.mode-btn'); if(!btn) return;
      e.stopPropagation();
      const mode = btn.getAttribute('data-mode');
      changeGraphMode(contentId, mode);
      tabs.querySelectorAll('.mode-btn').forEach(b=>b.classList.remove('active'));
      btn.classList.add('active');
    });

    header.appendChild(leftPart);
    header.appendChild(tabs);
    header.onclick=()=>toggleForecast(contentId);
    section.appendChild(header);

    const content=document.createElement('div'); content.className='forecast-content'; content.id=contentId; content.style.display='block';
    const wrapper=document.createElement('div'); wrapper.className='forecast-scroll-wrapper';
    const leftBtn=document.createElement('button'); leftBtn.className='scroll-left'; leftBtn.textContent='‚óÄ';
    const rightBtn=document.createElement('button'); rightBtn.className='scroll-right'; rightBtn.textContent='‚ñ∂';
    const scroll=document.createElement('div'); scroll.className='forecast-scroll';
    leftBtn.onclick=()=>scroll.scrollBy({left:-250,behavior:'smooth'});
    rightBtn.onclick=()=>scroll.scrollBy({left:250,behavior:'smooth'});
    wrapper.appendChild(leftBtn); wrapper.appendChild(scroll); wrapper.appendChild(rightBtn);

    entries.forEach(e => {
      const card=document.createElement('div'); card.className='forecast-card';
      const icon=getWeatherIcon(e.cloud, e.rain);
      card.innerHTML=`<div><strong>${e.time}</strong></div>
                      <div style="font-size:1.4em">${icon}</div>
                      <div>${Math.round(e.temp)}¬∞C</div>
                      <div>‚òÅÔ∏è ${Math.round(e.cloud)}%</div>
                      <div>üåßÔ∏è ${e.rain} mm</div>
                      <div>üí® ${Math.round(e.wind)} km/h</div>`;
      scroll.appendChild(card);
    });

    content.appendChild(wrapper);
    section.appendChild(content);
    div.appendChild(section);

    window._graphData[contentId] = { entries, date };
    window._graphMode[contentId] = 'seeing';
    requestAnimationFrame(()=> drawBackgroundGraph(scroll, entries, date, 'seeing'));
  });

  syncMapHeight();
}

/* ===== Toggle & focus helpers ===== */
function toggleForecast(id){const c=document.getElementById(id);const i=$(id+'-icon');if(c.style.display==='none'){c.style.display='block';i.textContent='‚¨ÜÔ∏è'}else{c.style.display='none';i.textContent='‚¨áÔ∏è'}}
function goToStart(contentId){const sc=document.querySelector(`#${contentId} .forecast-scroll`);if(!sc)return;sc.scrollTo({left:0,behavior:'smooth'});}
function centerTime(contentId,target){
  const sc=document.querySelector(`#${contentId} .forecast-scroll`); if(!sc) return;
  const cards=sc.querySelectorAll('.forecast-card');
  let found=false;
  for(let i=0;i<cards.length;i++){
    const strong=cards[i].querySelector('strong');
    if(strong&&strong.textContent.trim()===target){
      const w=sc.clientWidth;const off=cards[i].offsetLeft;const cw=cards[i].offsetWidth;
      sc.scrollTo({left:off-(w/2)+(cw/2),behavior:'smooth'});
      found=true;break;
    }
  }
  if(!found){ // pokud konkr√©tn√≠ hodina chyb√≠ (t≈ôeba u dne≈°ka), vra≈• na zaƒç√°tek
    goToStart(contentId);
  }
}

/* Change graph mode for a given day */
function changeGraphMode(contentId, mode){
  window._graphMode[contentId] = mode;
  const sc = document.querySelector(`#${contentId} .forecast-scroll`);
  const data = window._graphData[contentId];
  if(sc && data){
    drawBackgroundGraph(sc, data.entries, data.date, mode);
  }
}

/* ===== Planets @22:00 ===== */
async function fetchPlanets(lat,lon){
  const box=$("planets-list"); const log=(m)=>$("planet-log").textContent=m;
  box.innerHTML=""; log("poƒç√≠t√°m‚Ä¶");
  const render = (list) => {
    box.innerHTML="";
    let any=false;
    for(const p of list){
      if(Number.isFinite(p.alt)&&p.alt>5){
        const el=document.createElement("span"); el.className="pill"; el.title=`Azimut ${p.az.toFixed(0)}¬∞ v 22:00`; el.textContent=`${p.label}: ${p.alt.toFixed(0)}¬∞`; box.appendChild(el); any=true;
      }
    }
    if(!any) box.innerHTML = `<span class="small">≈Ω√°dn√© planety nejsou dob≈ôe viditeln√© v 22:00.</span>`;
    log("");
    syncMapHeight();
  };
  try{
    if(!window.Astronomy) throw new Error("Astronomy Engine nenaƒçten");
    const Body=window.Astronomy.Body;
    const mapEnum = {Mercury:Body.Mercury, Venus:Body.Venus, Mars:Body.Mars, Jupiter:Body.Jupiter, Saturn:Body.Saturn, Uranus:Body.Uranus, Neptune:Body.Neptune};
    const now=new Date(); const t=new Date(now.getFullYear(), now.getMonth(), now.getDate(), 22, 0, 0);
    const obs=new window.Astronomy.Observer(lat, lon, 0);
    const names=[["Mercury","Merkur"],["Venus","Venu≈°e"],["Mars","Mars"],["Jupiter","Jupiter"],["Saturn","Saturn"],["Uran","Uran"],["Neptune","Neptun"]];
    const out=[];
    for(const [eng, label] of names){
      const hor=window.Astronomy.Horizontal(t, obs, mapEnum[eng], 'normal');
      out.push({label, alt: hor.altitude, az: hor.azimuth});
    }
    render(out);
  }catch(e){
    try{
      const url=`https://api.ipgeolocation.io/astronomy?apiKey=${IPGEO_API_KEY}&lat=${lat}&long=${lon}`;
      const r=await fetch(url); const d=await r.json();
      const out=[
        {label:"Merkur", alt:+d.mercury_altitude, az:+d.mercury_azimuth},
        {label:"Venu≈°e", alt:+d.venus_altitude,   az:+d.venus_azimuth},
        {label:"Mars",   alt:+d.mars_altitude,    az:+d.mars_azimuth},
        {label:"Jupiter",alt:+d.jupiter_altitude, az:+d.jupiter_azimuth},
        {label:"Saturn", alt:+d.saturn_altitude,  az:+d.saturn_azimuth},
        {label:"Uran",   alt:+d.uranus_altitude,  az:+d.uranus_azimuth},
        {label:"Neptun", alt:+d.neptune_altitude, az:+d.neptune_azimuth}
      ];
      render(out);
    }catch(err){
      box.innerHTML=`<span class="small">Chyba naƒç√≠t√°n√≠ planet.</span>`; log("");
    }
  }
}

window.addEventListener('load', syncMapHeight);

/* ===== RainViewer overlays: radar + IR clouds ===== */
let rvState = {
  host: 'https://tilecache.rainviewer.com',
  radarPath: null,
  satPath: null,
  radarLayer: null,
  satLayer: null,
  control: null,
  lastTsRadar: 0,
  lastTsSat: 0
};

async function loadRainviewerMeta(){
  try{
    const res = await fetch('https://api.rainviewer.com/public/weather-maps.json', { cache: 'no-store' });
    const data = await res.json();
    rvState.host = data.host || rvState.host;

    // latest radar: prefer nowcast if available, else last past
    let radarFrames = (data.radar?.nowcast && data.radar.nowcast.length ? data.radar.nowcast : data.radar?.past) || [];
    if(radarFrames.length){
      const last = radarFrames[radarFrames.length - 1];
      rvState.radarPath = last.path;
      rvState.lastTsRadar = last.time;
    }

    // latest satellite IR (clouds)
    const satFrames = (data.satellite?.infrared) || [];
    if(satFrames.length){
      const last = satFrames[satFrames.length - 1];
      rvState.satPath = last.path;
      rvState.lastTsSat = last.time;
    }
  }catch(e){
    console.warn('RainViewer meta fetch failed', e);
  }
}

function ensureRvLayers(){
  if(!map) return;
  // create/update radar layer
  if(rvState.radarPath){
    const url = `${rvState.host}${rvState.radarPath}/256/{z}/{x}/{y}/2/1_1.png`;
    if(rvState.radarLayer){
      rvState.radarLayer.setUrl(url);
    } else {
      rvState.radarLayer = L.tileLayer(url, { opacity: 0.65, zIndex: 450, attribution: 'Radar ¬© RainViewer' });
    }
  }
  // create/update satellite IR layer (clouds)
  if(rvState.satPath){
    const urlSat = `${rvState.host}${rvState.satPath}/256/{z}/{x}/{y}/0/0_0.png`; // satellite requires color=0 and options 0_0
    if(rvState.satLayer){
      rvState.satLayer.setUrl(urlSat);
    } else {
      rvState.satLayer = L.tileLayer(urlSat, { opacity: 0.5, zIndex: 440, attribution: 'Satellite ¬© RainViewer' });
    }
  }

  // add layer control once
  if(!rvState.control){
    const overlays = {};
    if(rvState.satLayer) overlays['‚òÅÔ∏è Oblaƒçnost (IR)'] = rvState.satLayer;
    if(rvState.radarLayer) overlays['üåßÔ∏è Sr√°≈ækov√Ω radar'] = rvState.radarLayer;
    rvState.control = L.control.layers({}, overlays, { collapsed: false, position: 'topleft' }).addTo(map);
  } else {
    // update existing control (Leaflet has no direct API to refresh; simple approach: remove/add control)
    map.removeControl(rvState.control);
    const overlays = {};
    if(rvState.satLayer) overlays['‚òÅÔ∏è Oblaƒçnost (IR)'] = rvState.satLayer;
    if(rvState.radarLayer) overlays['üåßÔ∏è Sr√°≈ækov√Ω radar'] = rvState.radarLayer;
    rvState.control = L.control.layers({}, overlays, { collapsed: false, position: 'topleft' }).addTo(map);
  }
}

async function refreshWeatherLayers(){
  const prevRadar = rvState.lastTsRadar;
  const prevSat = rvState.lastTsSat;
  await loadRainviewerMeta();
  if(rvState.lastTsRadar && rvState.lastTsRadar !== prevRadar){
    ensureRvLayers();
  }
  if(rvState.lastTsSat && rvState.lastTsSat !== prevSat){
    ensureRvLayers();
  }
}

async function enableWeatherLayers(){
  await loadRainviewerMeta();
  ensureRvLayers();
}

// refresh every 10 minutes
setInterval(()=>{
  refreshWeatherLayers();
}, 10*60*1000);



/* ===== Diagnostics (minimal) ===== */
const diagList = document.getElementById('diagList');
function el(tag, attrs={}, html=""){
  const e=document.createElement(tag);
  for(const [k,v] of Object.entries(attrs)) e.setAttribute(k,v);
  if(html) e.innerHTML=html;
  return e;
}
function statusRow(name, statusClass, text){
  const row = el('div', {class:'diag-item'});
  row.appendChild(el('div',{class:'diag-name'}, name));
  row.appendChild(el('div',{class:'diag-status '+statusClass}, text));
  return row;
}
async function ping(url, timeout=4500){
  const controller = new AbortController();
  const id = setTimeout(()=>controller.abort(), timeout);
  try{
    const r = await fetch(url, {signal: controller.signal, method:'GET'});
    clearTimeout(id);
    return {ok:r.ok, status:r.status};
  }catch(e){
    clearTimeout(id);
    return {ok:false, status:'‚Äî'};
  }
}
async function runDiagnostics(){
  if(!diagList) return;
  diagList.innerHTML = "";
  const endpoints = [
    { name: "Open-Meteo Forecast", url: "https://api.open-meteo.com/v1/forecast?latitude=50.08&longitude=14.44&hourly=temperature_2m&timezone=Europe%2FPrague" },
    { name: "ipgeolocation Astronomy", url: `https://api.ipgeolocation.io/astronomy?apiKey=${IPGEO_API_KEY}&lat=50.08&long=14.44` },
    { name: "Nominatim Reverse", url: "https://nominatim.openstreetmap.org/reverse?format=json&lat=50.08&lon=14.44&zoom=10&addressdetails=1" }
  ];
  for(const ep of endpoints){
    const row = statusRow(ep.name, 'pending', 'ƒçek√°m‚Ä¶');
    diagList.appendChild(row);
    ping(ep.url).then(res=>{
      const s = row.querySelector('.diag-status');
      if(res.ok){ s.className='diag-status ok'; s.textContent='OK '+res.status; }
      else { s.className='diag-status fail'; s.textContent='Chyba '+res.status; }
    });
  }
}
function openDiagModal(){
  const overlay = document.getElementById('diagOverlay');
  if(overlay){ overlay.style.display='flex'; runDiagnostics(); }
}
function closeDiagModal(){
  const overlay = document.getElementById('diagOverlay');
  if(overlay){ overlay.style.display='none'; }
}
document.getElementById('openDiag')?.addEventListener('click', (e)=>{ e.preventDefault(); openDiagModal(); });
document.getElementById('closeDiag')?.addEventListener('click', (e)=>{ e.preventDefault(); closeDiagModal(); });
document.getElementById('rerunDiag')?.addEventListener('click', (e)=>{ e.preventDefault(); runDiagnostics(); });
document.addEventListener('keydown', (e)=>{ if(e.key==='Escape'){ closeDiagModal(); } });
</script>
</body>
</html>
