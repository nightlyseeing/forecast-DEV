<!DOCTYPE html>

<html lang="cs">
<head>
<style>
  .version-tag {
    position: fixed;
    top: 10px;
    right: 10px;
    background: #00ffc3;
    color: #000;
    font-weight: bold;
    padding: 4px 10px;
    border-radius: 8px;
    font-size: 0.9em;
    z-index: 9999;
    box-shadow: 0 0 8px rgba(0,255,195,0.6);
  }



#locationInfoBox {
  font-size: 1.05em;
  border: 1px solid #00ffc3;
  box-shadow: 0 0 8px rgba(0,255,195,0.2);
  padding: 16px;
  background: rgba(0, 255, 195, 0.03);
}

#locationInfoBox strong {
  color: #00ffc3;
  font-size: 1.2em;
}

#info-name {
  font-size: 1.2em;
  color: #e0e0e0;
  font-weight: bold;
  text-shadow: 0 0 3px #00ffc3;
}

#info-gps {
  font-size: 1.1em;
  color: #bbbbbb;
}
</style>
<meta charset="utf-8"/>
<meta content="width=device-width, initial-scale=1.0" name="viewport"/>
<title>Astronomick√° p≈ôedpovƒõƒè</title>
<link href="https://fonts.googleapis.com/css2?family=Orbitron:wght@400;600&amp;display=swap" rel="stylesheet"/>
<style>
    :root {
      --primary: #4b3f72;
      --secondary: #2e8b57;
      --background-dark: #0b0c10;
      --panel-bg: #1f2833;
      --border-color: #3e5363;
      --text-color: #dcdcdc;
    }

    
body {
  font-family: 'Orbitron', sans-serif;
  background: linear-gradient(to bottom, #0b0c1a, #1b2c3a);
  background-size: 400% 400%;
  animation: gradientShift 60s ease infinite;
  color: var(--text-color);
  padding: 20px;
  margin: 0;
  position: relative;
  overflow-x: hidden;
}
@keyframes gradientShift {
  0% { background-position: 0% 50%; }
  50% { background-position: 100% 50%; }
  100% { background-position: 0% 50%; }
}
    

  #cityDisplay {
    font-size: 1.2em;
    color: #00ffc3;
    background: rgba(255, 255, 255, 0.05);
    border: 1px solid #3e5363;
    border-radius: 10px;
    padding: 10px 20px;
    display: inline-block;
    margin: 10px auto;
    text-shadow: 0 0 5px #00ffc3;
  }

    .starry-bg {
      position: fixed;
      width: 100%;
      height: 100%;
      background: transparent;
      z-index: -1;
      pointer-events: none;
    }

    .starry-bg::before {
      content: '';
      position: absolute;
      top: -100%;
      left: 0;
      width: 100%;
      height: 300%;
      background: transparent;
      box-shadow:
        10px 20px white,
        50px 80px #888,
        90px 150px white,
        200px 300px #aaa,
        300px 50px #777,
        400px 500px white,
        600px 200px #999,
        800px 100px white,
        1000px 400px #666,
        1200px 250px white;
      animation: stars-fall 60s linear infinite;
      opacity: 0.5;
    }

    @keyframes stars-fall {
      0% { transform: translateY(0); }
      100% { transform: translateY(100%); }
    }

    h1, h2 {
      text-align: center;
      color: #ffffff;
    }

    .controls {
      text-align: center;
      margin-bottom: 20px;
      display: flex;
      justify-content: center;
      align-items: center;
      gap: 5px;
      flex-wrap: wrap;
    }

    .input-wrapper {
      position: relative;
      display: inline-block;
    }

    #cityInput {
      padding: 10px 35px 10px 10px;
      width: 300px;
      border-radius: 8px;
      border: 1px solid var(--border-color);
      background-color: #121212;
      color: var(--text-color);
    }

    .clear-btn {
      position: absolute;
      right: 10px;
      top: 50%;
      transform: translateY(-50%);
      background: none;
      border: none;
      font-size: 14px;
      cursor: pointer;
      color: #ccc;
      display: none;
      line-height: 1;
    }

    .controls button {
  transition: all 0.3s ease;
  box-shadow: 0 0 8px rgba(0, 255, 195, 0.3);
      padding: 10px;
      border-radius: 8px;
      border: none;
      background: var(--primary);
      color: white;
      cursor: pointer;
      font-weight: 600;
      transition: background 0.3s;
    }

    .controls button:hover {
      background: var(--secondary);
    }

    #suggestions {
      position: absolute;
      top: 100%;
      left: 0;
      background: #121212;
      border: 1px solid var(--border-color);
      border-radius: 8px;
      width: 100%;
      list-style: none;
      padding: 0;
      margin-top: 5px;
      z-index: 1000;
      display: none;
      box-shadow: 0 2px 5px rgba(0,0,0,0.7);
    }

    #suggestions li {
      padding: 10px;
      cursor: pointer;
    }

    #suggestions li:hover {
      background-color: var(--primary);
      color: white;
    }

    .layout {
      display: flex;
      flex-wrap: wrap;
      gap: 20px;
      align-items: flex-start;
    }

    .map-container {
  display: flex;
  flex-direction: column;
  align-items: stretch;
  width: 30%;
  min-width: 200px;
}

    #map {
  width: 100%;
  aspect-ratio: 1 / 1;
  border-radius: 10px;
}

    .info-container {
      flex: 1 1 55%;
    }

    .moon-phase {
      background: var(--panel-bg);
      border: 1px solid var(--border-color);
      border-radius: 10px;
      padding: 15px;
      margin-bottom: 20px;
      box-shadow: 0 2px 10px rgba(0,0,0,0.6);
    }

    .moon-phase img {
      width: 100%;
      border-radius: 8px;
      margin-top: 10px;
    }

    .forecast-day {
      margin-bottom: 10px;
      border: 1px solid var(--border-color);
      border-radius: 10px;
      background: var(--panel-bg);
    }

    .forecast-day h3 {
      margin: 0;
      padding: 10px;
      cursor: pointer;
      background: var(--primary);
      color: white;
      border-radius: 10px 10px 0 0;
      display: flex;
      justify-content: flex-start;
      align-items: center;
      gap: 10px;
    }

    .forecast-content {
      display: none;
      padding: 10px;
      height: auto; overflow: visible; }

    table {
      width: 100%;
      border-collapse: collapse;
    }

    th, td {
      padding: 8px;
      border: 1px solid #333;
      text-align: center;
    }

    .spinner {
      display: none;
      margin: 0 auto;
      border: 8px solid #333;
      border-top: 8px solid var(--primary);
      border-radius: 50%;
      width: 50px;
      height: 50px;
      animation: spin 1s linear infinite;
    }

    @keyframes spin {
      100% { transform: rotate(360deg); }
    }
  
    .forecast-scroll {
      display: flex;
      overflow-x: auto;
      gap: 10px;
      padding: 10px 0;
    }

    .forecast-card {
      min-width: 70px;
      font-size: 0.8em;
      background: #2c2f33;
      border: 1px solid var(--border-color);
      border-radius: 8px;
      padding: 6px;
      text-align: center;
      flex-shrink: 0;
    }

    .forecast-card span {
      display: block;
      margin-bottom: 5px;
    }

    .layout {
      display: flex;
      flex-wrap: nowrap;
      gap: 20px;
      height: 90vh;
      align-items: stretch;
    }

    .info-container {
      width: 70%;
      display: flex;
      flex-direction: column;
    }

    .map-container {
  display: flex;
  flex-direction: column;
  align-items: stretch;
  width: 30%;
  min-width: 200px;
}

    #map {
  width: 100%;
  aspect-ratio: 1 / 1;
  border-radius: 10px;
}

    #locationInfoBox {
      position: sticky;
      top: 0;
      background: var(--panel-bg);
      z-index: 10;
      border-bottom: 1px solid var(--border-color);
      margin-bottom: 10px;
    }


    .layout {
      display: flex;
      flex-wrap: nowrap;
      gap: 20px;
      align-items: flex-start;
    }

    .info-container {
      flex: 1 1 60%;
      display: flex;
      flex-direction: column;
    }

    .map-container {
      flex: 1 1 40%;
      display: flex;
      flex-direction: column;
      align-items: stretch;
    }

    .map-section-item {
      width: 100%;
      aspect-ratio: 1 / 1;
      border-radius: 10px;
      overflow: hidden;
    }

    .map-section-item iframe {
      width: 100%;
      height: 100%;
      border: none;
    }
    
  h1 {
    margin: 10px 0 5px 0;
    font-size: 1.8em;
  }
  .controls {
    margin-bottom: 10px;
  }
  body {
    padding: 10px;
  }

  #cityInput {
    padding: 6px 30px 6px 8px;
    width: 240px;
  }
  .controls button {
  transition: all 0.3s ease;
  box-shadow: 0 0 8px rgba(0, 255, 195, 0.3);
    padding: 6px 10px;
    font-size: 0.9em;
  }

  
body {
  font-family: 'Orbitron', sans-serif;
  background: linear-gradient(to bottom, #0b0c1a, #1b2c3a);
  background-size: 400% 400%;
  animation: gradientShift 60s ease infinite;
  color: var(--text-color);
  padding: 20px;
  margin: 0;
  position: relative;
  overflow-x: hidden;
}
@keyframes gradientShift {
  0% { background-position: 0% 50%; }
  50% { background-position: 100% 50%; }
  100% { background-position: 0% 50%; }
}
    
  @keyframes bg-fade {
    0% { background: radial-gradient(ellipse at bottom, #1b2c45 0%, #0d0f1a 100%); }
    100% { background: radial-gradient(ellipse at bottom, #223b5f 0%, #151826 100%); }
  }

  .input-wrapper {
    box-shadow: 0 0 10px rgba(0,255,195,0.4);
    border-radius: 10px;
    background: rgba(0, 255, 195, 0.05);
    padding: 5px;
  }
  #cityInput {
    font-size: 1em;
    font-weight: bold;
    border: 2px solid #00ffc3;
    background-color: #111;
    color: #00ffc3;
    transition: box-shadow 0.3s ease;
  }
  #cityInput:focus {
    outline: none;
    box-shadow: 0 0 12px #00ffc3;
  }
</style>
<script src="https://cdn.jsdelivr.net/npm/astronomy-engine@2.1.0/astronomy.js"></script></head>
<body>
<div class="version-tag">Verze 0.1</div>
<div class="starry-bg"></div>
<h1 style="font-size:2.2em; text-shadow: 0 0 15px #00ffc3;">ü™ê Astronomick√° p≈ôedpovƒõƒè</h1>
<div class="controls">
<div class="input-wrapper">
<input id="cityInput" oninput="autocompleteCities(); document.querySelector('.clear-btn').style.display = this.value ? 'block' : 'none';" placeholder="Zadejte mƒõsto..." type="text"/>
<button class="clear-btn" onclick="document.getElementById('cityInput').value=''; this.style.display='none'; document.getElementById('suggestions').style.display='none';">√ó</button>
<ul id="suggestions"></ul>
</div>
<h2 id="cityDisplay" style="display:none; text-align:center; font-size: 1.5em; color:#00ffc3; text-shadow: 0 0 5px #00ffc3;"></h2>
<button onclick="getLocation()">üìç Moje poloha</button>
</div>
<div class="layout">
<!-- Lev√Ω sloupec: Info + p≈ôedpovƒõƒè -->
<div class="info-container"><div style="display: flex; gap: 20px;"><div class="moon-phase" id="locationInfoBox" style=" width: 50%;">
<strong><u><span style="font-size: 1.2em;">üìç Informace o m√≠stƒõ</span></u></strong>
<div><strong>üåÜ N√°zev:</strong> <span id="info-name">-</span></div>
<div><strong>üåê GPS:</strong> <span id="info-gps">-</span></div>
<div style="margin-top: 8px;">

</div>
</div><div class="moon-phase" id="astroInfoBox" style=" width: 50%;"><strong>üî≠ Astronomick√© informace</strong><div id="moon-phase-display" style="margin-top: 8px; font-size: 1.05em;">
<strong>üåô F√°ze Mƒõs√≠ce:</strong> <span id="moon-phase-label">‚Äî</span>
</div><a href="#" id="bortle-link" style="color:#00ffc3; font-weight:bold; text-decoration:underline;" target="_blank">
    üåå Zobrazit Bortleovu t≈ô√≠du
  </a></div></div>
<div class="spinner" id="spinner"></div>
<div id="forecast"></div>
</div>
<!-- Prav√Ω sloupec: Mapa -->
<div class="map-container">
<div class="map-section-item" id="windyWrapper" style="width: 100%; margin-top: 10px; display: none; position: relative;">
<div id="windyOverlayBlocker" style="position:absolute;top:0;left:0;right:0;bottom:0;z-index:2;"></div>
<iframe frameborder="0" id="windyFrame" src="https://embed.windy.com/embed2.html?lat=50.08&amp;lon=14.43&amp;zoom=11&amp;level=surface&amp;overlay=satellite&amp;menu=&amp;message=&amp;marker=&amp;calendar=now&amp;type=satellite&amp;location=coordinates&amp;detail=&amp;metricWind=default&amp;metricTemp=default" style="border-radius: 10px; display: block; position:relative; z-index:1;" width="100%">
</iframe>
</div>
<script>
  // Kliknut√≠m aktivuj interakci, jinak scroll z≈Østane neaktivn√≠
  const windyWrapper = document.getElementById("windyWrapper");
  const blocker = document.getElementById("windyOverlayBlocker");
  blocker.addEventListener("click", () => {
    blocker.style.display = "none";
  });

function centerTime(contentId, targetTime) {
  const scrollContainer = document.querySelector(`#${contentId} .forecast-scroll`);
  if (!scrollContainer) return;
  const cards = scrollContainer.querySelectorAll('.forecast-card');

  for (const card of cards) {
    const time = card.querySelector('span strong')?.textContent;
    if (time === targetTime) {
      const containerWidth = scrollContainer.offsetWidth;
      const cardOffset = card.offsetLeft;
      const cardWidth = card.offsetWidth;
      scrollContainer.scrollLeft = cardOffset - (containerWidth / 2) + (cardWidth / 2);
      break;
    }
  }
}

</script>
</div>
</div>
<script>
  let selectedCity = null;
  let map = null;
  let marker = null;

  function toggleForecast(dayId) {
    const content = document.getElementById(dayId);
    const icon = document.getElementById(dayId + '-icon');
    if (content.style.display === 'none') {
      content.style.display = 'block';
      icon.textContent = '‚¨ÜÔ∏è';
    } else {
      content.style.display = 'none';
      icon.textContent = '‚¨áÔ∏è';
    }
  }

  function showSpinner(show) {
    document.getElementById('spinner').style.display = show ? 'block' : 'none';
  }

  function getWeatherIcon(cloud, rain) {
    if (rain > 2) return 'üåßÔ∏è';
    if (rain > 0) return 'üå¶Ô∏è';
    if (cloud > 75) return '‚òÅÔ∏è';
    if (cloud > 25) return 'üå§Ô∏è';
    return '‚òÄÔ∏è';
  }

  
function getDayName(dateStr) {
  const today = new Date().toISOString().split('T')[0];
  if (dateStr === today) return "Dnes";

    const days = ['Nedƒõle', 'Pondƒõl√≠', '√öter√Ω', 'St≈ôeda', 'ƒåtvrtek', 'P√°tek', 'Sobota'];
    const date = new Date(dateStr);
    return days[date.getDay()];
  }

  async function autocompleteCities() {
    const input = document.getElementById('cityInput').value.trim();
    const suggestions = document.getElementById('suggestions');
    if (input.length < 2) return suggestions.style.display = 'none';
    const res = await fetch(`https://geocoding-api.open-meteo.com/v1/search?name=${encodeURIComponent(input)}&count=5&language=cs&format=json`);
    const data = await res.json();
    suggestions.innerHTML = '';
    (data.results || []).forEach(city => {
      const li = document.createElement('li');
      li.textContent = `${city.name}, ${city.country}`;
      li.onclick = () => {
  selectedCity = city;
  document.getElementById('cityInput').value = `${city.name}, ${city.country}`;
  document.getElementById('cityDisplay').textContent = `${city.name}, ${city.country}`;
  updateLocationInfo(city);
        suggestions.style.display = 'none';
        initMap(city.latitude, city.longitude);
        fetchForecast(city.latitude, city.longitude);
        fetchMoonPhase(city.latitude, city.longitude);
        fetchPlanets(city.latitude, city.longitude);
        updateLocationInfo(city);
      };
      suggestions.appendChild(li);
    });
    suggestions.style.display = 'block';
  }

  async function manualSearch() {
    const input = document.getElementById('cityInput').value.trim();
    if (!input) return alert("Zadejte mƒõsto");
    const res = await fetch(`https://geocoding-api.open-meteo.com/v1/search?name=${encodeURIComponent(input)}&count=1&language=cs&format=json`);
    const data = await res.json();
    if (!data.results || !data.results.length) return alert("Mƒõsto nenalezeno.");
    selectedCity = data.results[0];
    document.getElementById('cityDisplay').textContent = `${selectedCity.name}, ${selectedCity.country}`;
    console.log('Manu√°lnƒõ zadan√© mƒõsto:', selectedCity);
    initMap(selectedCity.latitude, selectedCity.longitude);
    fetchForecast(selectedCity.latitude, selectedCity.longitude);
    fetchMoonPhase(selectedCity.latitude, selectedCity.longitude);
    updateLocationInfo(selectedCity);
  }

  async function getLocation() {
    navigator.geolocation.getCurrentPosition(async pos => {
      const lat = pos.coords.latitude;
      const lon = pos.coords.longitude;
      const name = await reverseGeocode(lat, lon);
      console.log('Lokace nalezena:', name);
      initMap(lat, lon);
      updateLocationInfo({ name, country: '', latitude: lat, longitude: lon });
      fetchForecast(lat, lon);
      fetchMoonPhase(lat, lon);
      fetchPlanets(lat, lon);
      updateLocationInfo({ name, country: '', latitude: lat, longitude: lon });
    }, err => alert("Nepoda≈ôilo se zjistit polohu."));
  }

  async function reverseGeocode(lat, lon) {
    try {
      const res = await fetch(`https://nominatim.openstreetmap.org/reverse?format=json&lat=${lat}&lon=${lon}&zoom=10&addressdetails=1`);
      const data = await res.json();
      const name = data.address?.city || data.address?.town || data.address?.village || data.address?.municipality || data.display_name || `${lat.toFixed(4)}, ${lon.toFixed(4)}`;
      document.getElementById('cityDisplay').textContent = name;
      return name;
    } catch {
      const fallback = `${lat.toFixed(4)}, ${lon.toFixed(4)}`;
      document.getElementById('cityDisplay').textContent = fallback;
      return fallback;
    }
  }

  function initMap(lat, lon) {
    if (!map) {
      map = L.map('map', { scrollWheelZoom: false }).setView([lat, lon], 10);
      L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
        maxZoom: 19,
        attribution: '¬© OpenStreetMap'
      }).addTo(map);
      marker = L.marker([lat, lon]).addTo(map);
    } else {
      map.setView([lat, lon], 10);
      marker.setLatLng([lat, lon]);
    }
  }

  
async function fetchForecast(lat, lon) {
  showSpinner(true);
  const res = await fetch(`https://api.open-meteo.com/v1/forecast?latitude=${lat}&longitude=${lon}&hourly=temperature_2m,cloudcover,precipitation,windspeed_10m&timezone=Europe/Prague`);
  const data = await res.json();
  showSpinner(false);
  const { time, temperature_2m, cloudcover, precipitation, windspeed_10m } = data.hourly;
  const forecastDiv = document.getElementById('forecast');
  forecastDiv.innerHTML = '';

  const days = {};

  for (let i = 0; i < time.length; i++) {
    const [date, hour] = time[i].split('T');
    const hourNum = parseInt(hour.split(':')[0]);

    // Hlavn√≠ den
    if (!days[date]) days[date] = [];
    days[date].push({
      time: hour,
      temp: temperature_2m[i],
      cloud: cloudcover[i],
      rain: precipitation[i],
      wind: windspeed_10m[i]
    });

    // P≈ôid√°n√≠ ƒças≈Ø do p≈ôedchoz√≠ho dne (pro roz≈°√≠≈ôen√≠ na 36 hodin)
    if (hourNum < 12) {
      const prevDate = new Date(date);
      prevDate.setDate(prevDate.getDate() - 1);
      const prevDateStr = prevDate.toISOString().split('T')[0];
      if (!days[prevDateStr]) days[prevDateStr] = [];
      days[prevDateStr].push({
        time: hour,
        temp: temperature_2m[i],
        cloud: cloudcover[i],
        rain: precipitation[i],
        wind: windspeed_10m[i]
      });
    }
  }

  

Object.entries(days).forEach(([date, entries], idx) => {
  // Zobraz den pouze pokud m√° alespo≈à jednu hodinu od 12:00 d√°l
  if (!entries.some(e => {
    const h = parseInt(e.time.split(':')[0]);
    return h >= 12;
  })) return;


    const section = document.createElement('div');
    section.className = 'forecast-day';

    const header = document.createElement('h3');
    const contentId = `day-${idx}`;
    const dayName = getDayName(date);
    header.innerHTML = `
      <span id="${contentId}-icon">‚¨ÜÔ∏è</span> ${dayName}, ${date}
      <button onclick="event.stopPropagation(); centerTime('${contentId}', '12:00')">Poledne</button>
      <button onclick="event.stopPropagation(); centerTime('${contentId}', '23:00')">P≈Ølnoc</button>
      `;
    header.onclick = () => toggleForecast(contentId);
    section.appendChild(header);

    const content = document.createElement('div');
    content.className = 'forecast-content';
    content.id = contentId;
    content.style.display = 'block';

    const scrollContainer = document.createElement('div');
    scrollContainer.className = 'forecast-scroll';

    entries
      .filter(e => {
        if (date === new Date().toISOString().split('T')[0]) {
          const currentHour = new Date().getHours();
          return parseInt(e.time.split(':')[0]) >= currentHour;
        }
        return true;
      })
      .forEach(e => {
        const card = document.createElement('div');
        card.className = 'forecast-card';
        const icon = getWeatherIcon(e.cloud, e.rain);
        
let qualityColor;
if (e.cloud <= 25) {
  qualityColor = 'green';
} else if (e.cloud <= 75) {
  qualityColor = 'orange';
} else {
  qualityColor = 'red';
}

card.innerHTML = `
          <span><strong>${e.time}</strong></span>
          <span>${icon}</span>
          <span>${e.temp}¬∞C</span>
          <span>‚òÅÔ∏è ${e.cloud}%</span>
          <span>üåßÔ∏è ${e.rain} mm</span>
          <span>üí® ${e.wind} km/h</span>
          <div style="width: 100%; height: 8px; background-color: ${qualityColor}; border-radius: 4px; margin-top: 4px;"></div>
    `;
        scrollContainer.appendChild(card);
      });

    content.appendChild(scrollContainer);
    section.appendChild(content);
    forecastDiv.appendChild(section);
  });
}


  
  
function fetchPlanets(lat, lon) {
  const log = (msg) => document.getElementById("planet-log").textContent = msg;

  try {
    log(`üìç Poloha: ${lat.toFixed(2)}, ${lon.toFixed(2)}`);
    const tbody = document.getElementById("planet-table");
    tbody.innerHTML = "";

    const observer = new Astronomy.Observer(lat, lon, 0);
    const date = new Date();
    date.setHours(22, 0, 0, 0);

    const planets = ["Mercury", "Venus", "Mars", "Jupiter", "Saturn"];
    let anyVisible = false;

    for (const body of planets) {
      const hor = Astronomy.Horizon(date, observer, body, "normal");
      if (hor.altitude > 5) {
        tbody.innerHTML += `<tr><td>${body}</td><td>${hor.altitude.toFixed(1)}</td><td>${hor.azimuth.toFixed(1)}</td></tr>`;
        anyVisible = true;
      }
    }

    if (!anyVisible) {
      tbody.innerHTML = "<tr><td colspan='3'>≈Ω√°dn√© planety nejsou dob≈ôe viditeln√©.</td></tr>";
    }

    log("‚úÖ Hotovo.");
  } catch (e) {
    log("‚ùå Chyba: " + e.message);
  }
}


function updateLocationInfo(city) {
    const name = city.name || '-';
    const country = city.country || '';
    const lat = typeof city.latitude === 'number' ? city.latitude.toFixed(4) : '-';
    const lon = typeof city.longitude === 'number' ? city.longitude.toFixed(4) : '-';
    document.getElementById('info-name').innerHTML = country
  ? `<span style="color:#00ffc3; font-weight:bold;">${name}</span>, ${country}`
  : `<span style="color:#00ffc3; font-weight:bold;">${name}</span>`;
    document.getElementById('info-gps').textContent = `${lat}, ${lon}`;
  }
  
</script>
<script>
  function resizeMapToSquare() {
    const mapDiv = document.getElementById('map');
    if (mapDiv) {
      const width = mapDiv.offsetWidth;
      mapDiv.style.height = `${width}px`;
      if (window.map) map.invalidateSize();
    }
  }

  window.addEventListener('load', resizeMapToSquare);
  window.addEventListener('resize', resizeMapToSquare);
</script>
<script>
  function updateWindyWidget(lat, lon) {
    const windy = document.getElementById('windyFrame');
    if (windy) {
      windy.src = `https://embed.windy.com/embed2.html?lat=${lat}&lon=${lon}&zoom=11&level=surface&overlay=satellite&menu=&message=&marker=&calendar=now&type=satellite&location=coordinates&detail=&metricWind=default&metricTemp=default`;
    }
  }

  function resizeWindyToMatchMap() {
    const mapDiv = document.getElementById('map');
    const windyDiv = document.getElementById('windyFrame');
    if (mapDiv && windyDiv) {
      const height = mapDiv.offsetHeight;
      windyDiv.style.height = height + 'px';
    }
  }

  window.addEventListener('load', resizeWindyToMatchMap);
  window.addEventListener('resize', resizeWindyToMatchMap);

  const originalInitMap = window.initMap;
  window.initMap = function(lat, lon) {
      updateWindyWidget(lat, lon);
      setTimeout(resizeWindyToMatchMap, 300);
      const windyWrap = document.getElementById('windyWrapper');
      if (windyWrap) windyWrap.style.display = 'block';
    };
</script>
<script>
function syncMapAndWidgetHeight() {
  const mapDiv = document.getElementById('map');
  const windyDiv = document.getElementById('windyFrame');
  if (mapDiv && windyDiv) {
    const height = mapDiv.offsetWidth;
    mapDiv.style.height = height + 'px';
    windyDiv.style.height = height + 'px';
  }
}
window.addEventListener('load', syncMapAndWidgetHeight);
window.addEventListener('resize', syncMapAndWidgetHeight);
</script>
<script>
  function updateBortleLink(lat, lon) {
    const link = document.getElementById('bortle-link');
    if (link && lat && lon) {
      link.href = `https://www.lightpollutionmap.info/#zoom=9&lat=${lat}&lon=${lon}`;
    }
  }

  // Extend updateLocationInfo to update the link
  const originalUpdateLocationInfo = window.updateLocationInfo;
  window.updateLocationInfo = function(city) {
    originalUpdateLocationInfo(city);
    if (city.latitude && city.longitude) {
      updateBortleLink(city.latitude.toFixed(4), city.longitude.toFixed(4));
    }
  }
</script>
<script src="moon_phase.js"></script><script>
function waitForAstronomy(callback) {
  if (typeof Astronomy !== "undefined") {
    callback();
  } else {
    setTimeout(() => waitForAstronomy(callback), 100);
  }
}

// Rebind planetary and moon calls to wait for library
const originalFetchPlanets = window.fetchPlanets;
window.fetchPlanets = function(lat, lon) {
  waitForAstronomy(() => originalFetchPlanets(lat, lon));
};

const originalFetchMoonPhase = window.fetchMoonPhase;
window.fetchMoonPhase = function(lat, lon) {
  waitForAstronomy(() => originalFetchMoonPhase(lat, lon));
};
</script>
<script>
async function fetchMoonPhase(lat, lon) {
  const apiKey = "781aa2d69af74745906e01cc68c84207";
  const url = `https://api.ipgeolocation.io/astronomy?apiKey=${apiKey}&lat=${lat}&long=${lon}`;
  try {
    const res = await fetch(url);
    const data = await res.json();
    const phase = data.moon_phase || "Nezn√°m√° f√°ze";
    document.getElementById("moon-phase-label").textContent = `${phase} ${getMoonEmojiFromName(phase)}`;
  } catch (err) {
    console.error("Chyba p≈ôi naƒç√≠t√°n√≠ f√°ze mƒõs√≠ce:", err);
    document.getElementById("moon-phase-label").textContent = "Chyba naƒç√≠t√°n√≠";
  }
}
</script>
<script>
async function fetchPlanets(lat, lon) {
  const apiKey = "781aa2d69af74745906e01cc68c84207";
  const url = `https://api.ipgeolocation.io/astronomy?apiKey=${apiKey}&lat=${lat}&long=${lon}`;
  const log = (msg) => document.getElementById("planet-log").textContent = msg;

  try {
    const res = await fetch(url);
    const data = await res.json();

    const tbody = document.getElementById("planet-table");
    tbody.innerHTML = "";

    const planets = [
      { name: "Mercury", altitude: data.mercury_altitude, azimuth: data.mercury_azimuth },
      { name: "Venus", altitude: data.venus_altitude, azimuth: data.venus_azimuth },
      { name: "Mars", altitude: data.mars_altitude, azimuth: data.mars_azimuth },
      { name: "Jupiter", altitude: data.jupiter_altitude, azimuth: data.jupiter_azimuth },
      { name: "Saturn", altitude: data.saturn_altitude, azimuth: data.saturn_azimuth }
    ];

    let anyVisible = false;

    for (const planet of planets) {
      if (planet.altitude > 5) {
        const row = `<tr><td>${planet.name}</td><td>${parseFloat(planet.altitude).toFixed(1)}</td><td>${parseFloat(planet.azimuth).toFixed(1)}</td></tr>`;
        tbody.innerHTML += row;
        anyVisible = true;
      }
    }

    if (!anyVisible) {
      tbody.innerHTML = "<tr><td colspan='3'>≈Ω√°dn√© planety nejsou dob≈ôe viditeln√©.</td></tr>";
    }

    log("‚úÖ Hotovo.");
  } catch (e) {
    log("‚ùå Chyba p≈ôi naƒç√≠t√°n√≠ planet: " + e.message);
  }
}
</script>
<script>
let moonPhasesByDate = {};

async function fetchMoonPhasesForecast(lat, lon) {
  try {
    const url = `https://api.open-meteo.com/v1/forecast?latitude=${lat}&longitude=${lon}&daily=moon_phase&timezone=Europe%2FPrague`;
    const res = await fetch(url);
    const data = await res.json();

    const dates = data.daily.time;
    const phases = data.daily.moon_phase;

    for (let i = 0; i < dates.length; i++) {
      const phaseValue = phases[i];
      const emoji = getMoonEmoji(phaseValue);
      moonPhasesByDate[dates[i]] = emoji;
    }
  } catch (err) {
    console.error("Chyba p≈ôi naƒç√≠t√°n√≠ mƒõs√≠ƒçn√≠ch f√°z√≠:", err);
  }
}

function getMoonEmoji(phase) {
  if (phase === 0 || phase === 1) return "üåë";       // New Moon
  if (phase > 0 && phase < 0.25) return "üåí";        // Waxing Crescent
  if (phase === 0.25) return "üåì";                   // First Quarter
  if (phase > 0.25 && phase < 0.5) return "üåî";      // Waxing Gibbous
  if (phase === 0.5) return "üåï";                    // Full Moon
  if (phase > 0.5 && phase < 0.75) return "üåñ";      // Waning Gibbous
  if (phase === 0.75) return "üåó";                   // Last Quarter
  return "üåò";                                       // Waning Crescent
}

// Modify headers to include emoji after forecast data is loaded
function addMoonPhasesToHeaders() {
  Object.entries(moonPhasesByDate).forEach(([date, emoji], idx) => {
    const headerEls = document.querySelectorAll(".forecast-day h3");
    headerEls.forEach(header => {
      if (header.textContent.includes(date) && !header.textContent.includes(emoji)) {
        header.innerHTML = header.innerHTML.replace(date, date + " " + emoji);
      }
    });
  });
}

// Patch fetchForecast to inject moon phase call
const originalFetchForecast = window.fetchForecast;
window.fetchForecast = async function(lat, lon) {
  await fetchMoonPhasesForecast(lat, lon);
  await originalFetchForecast(lat, lon);
  addMoonPhasesToHeaders();
};



function getMoonEmojiFromName(name) {
  const nameLower = name.toLowerCase().replace(/_/g, " ");
  if (nameLower.includes("new moon")) return "üåë";
  if (nameLower.includes("waxing crescent")) return "üåí";
  if (nameLower.includes("first quarter")) return "üåì";
  if (nameLower.includes("waxing gibbous")) return "üåî";
  if (nameLower.includes("full moon")) return "üåï";
  if (nameLower.includes("waning gibbous")) return "üåñ";
  if (nameLower.includes("last quarter")) return "üåó";
  if (nameLower.includes("waning crescent")) return "üåò";
  return "üåô";
}

</script></body></html>
