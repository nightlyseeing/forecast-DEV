<!DOCTYPE html>
<html lang="cs">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width, initial-scale=1.0"/>
<title>Astronomick√° p≈ôedpovƒõƒè ‚Äì seeing (üëÅÔ∏è), v√≠tr, d√©≈°≈•</title>

<link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" crossorigin=""/>
<script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js" crossorigin=""></script>
<script src="https://unpkg.com/suncalc@1.9.0/suncalc.js"></script>

<link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&family=Orbitron:wght@400;600&display=swap" rel="stylesheet"/>
<style>
  :root{
    --bg:#0b0c10; --panel:#1f2833; --accent:#00ffc3; --border:#3e5363; --text:#dcdcdc; --shadow:0 0 12px rgba(0,255,195,0.5);
    --green:#00ff88; --greenFill:rgba(0,255,136,0.22);
    --red:#ff4d4d;   --redFill:rgba(255,77,77,0.22);

    /* D√©≈°≈•: svƒõtle ‚Üí tmavƒõ modr√° (dole ‚Üí naho≈ôe) */
    --rainLow:#a5d8ff;   /* svƒõtle modr√° */
    --rainHigh:#1e3a8a;  /* tmavƒõ modr√° */

    /* V√≠tr: svƒõtle ‚Üí tmavƒõ zelen√° (dole ‚Üí naho≈ôe) */
    --windLow:#c7f9cc;   /* svƒõtle mint */
    --windHigh:#03543f;  /* tmavƒõ smaragdov√° */

    /* Teplota: svƒõtle ‚Üí tmavƒõ oran≈æov√°/ƒçerven√° (dole ‚Üí naho≈ôe) */
    --tempLow:#fde68a;   /* svƒõtle oran≈æov√° */
    --tempHigh:#ef4444;  /* ƒçerven√° */
  }
  *{box-sizing:border-box}
  body{margin:0;background:radial-gradient(ellipse at top,#0b0c1a 0%,#1b2c3a 100%);color:var(--text);padding:16px;font-family:'Inter', system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, sans-serif}

  /* === Page layout with ad gutters === */
  .layout{
    display:grid;
    grid-template-columns: 220px minmax(300px, 1200px) 220px; /* ad-left | main | ad-right */
    gap:16px;
    align-items:start;
    justify-content:center; /* centers the middle column, keeps gutters at sides */
  }
  .ad-slot{
    position:sticky; top:16px;
    min-height:200px;
    background:rgba(0,0,0,0.15);
    border:1px dashed rgba(255,255,255,0.2);
    border-radius:12px;
    display:flex; align-items:center; justify-content:center;
    text-align:center; padding:12px; font-size:.95em; opacity:.8;
  }
  /* On narrow screens, collapse to single column and hide ad slots */
  @media (max-width: 1200px){
    .layout{ grid-template-columns: 1fr; }
    .ad-slot{ display:none; }
  }

  h1{margin:8px 0 16px;text-align:center;color:#fff;font-size:2.1rem;text-shadow:0 0 16px var(--accent)}

  /* ===== Top bar with menu + centered NOW status ===== */
  .topbar{ position:sticky; top:0; z-index:15000; /* ‚Üë Fix: topbar nad vyhled√°vaƒçem i jeho n√°vrhy */
    display:grid; grid-template-columns:auto 1fr auto; align-items:center;
    padding:8px 10px;
    background:linear-gradient(180deg, rgba(11,12,16,0.92) 0%, rgba(11,12,16,0.70) 100%);
    border:1px solid rgba(255,255,255,0.08);
    border-radius:12px;
    backdrop-filter:saturate(140%) blur(6px);
    box-shadow:0 6px 18px rgba(0,0,0,.35);
  }
  .menu-container{position:relative;align-self:flex-start; z-index:9000}
  .menu-toggle{background:var(--accent);color:#000;font-weight:bold;padding:8px 14px;border-radius:10px;cursor:pointer;border:none;box-shadow:var(--shadow)}
  .menu-dropdown{display:none;position:absolute;top:110%;left:0;background:var(--panel);border:1px solid var(--border);border-radius:10px;min-width:240px;box-shadow:0 8px 16px rgba(0,0,0,.6);overflow:visible; z-index:9500}
  .menu-section{padding:6px 0;position:relative;border-bottom:1px solid rgba(255,255,255,.06)}
  .menu-section:last-child{border-bottom:none}
  .menu-item,.menu-link{display:flex;justify-content:space-between;align-items:center;gap:8px;padding:10px 16px;color:var(--accent);text-decoration:none;cursor:pointer;white-space:nowrap}
  .menu-item:hover,.menu-link:hover{background:#2e8b57;color:#fff}
  .submenu{display:none;position:absolute;top:0;left:100%;background:var(--panel);border:1px solid var(--border);border-radius:10px;min-width:230px;box-shadow:0 8px 16px rgba(0,0,0,.6); z-index:9600;}
  .has-submenu{position:relative}
  .has-submenu:hover>.submenu{display:block}

  .now-status{
    justify-self:center; /* center in grid middle column */
    display:flex; align-items:center; gap:10px;
    padding:6px 12px; border-radius:999px;
    border:1px solid var(--border);
    background:rgba(0,0,0,.35);
    box-shadow:0 2px 10px rgba(0,0,0,.35);
    font-weight:700;
  }
  .now-status .place{opacity:.9; font-weight:600; margin-right:4px}
  .now-status .sep{opacity:.4}
  .now-status .val{min-width:50px; text-align:center}

  /* ===== Diagnostics modal ===== */
  .modal-overlay{
    position:fixed; inset:0; background:rgba(0,0,0,0.6);
    display:none; align-items:center; justify-content:center; z-index:3000;
  }
  .modal{
    width:min(760px, 92vw); max-height:80vh; overflow:auto;
    background:var(--panel); border:1px solid var(--border); border-radius:14px;
    box-shadow:0 0 20px rgba(0,0,0,.6); padding:14px;
  }
  .modal header{display:flex; align-items:center; justify-content:space-between; gap:8px; margin-bottom:8px}
  .modal header h2{margin:0; font-size:1.25rem}
  .close-btn{background:none; color:#fff; border:1px solid var(--border); border-radius:8px; padding:6px 10px; cursor:pointer}
  .diag-item{display:flex;align-items:center;justify-content:space-between;gap:8px;padding:6px 0;border-bottom:1px solid rgba(255,255,255,.06)}
  .diag-item:last-child{border-bottom:none}
  .diag-name{opacity:.9}
  .diag-status{font-weight:700}
  .ok{color:#00ff88} .fail{color:#ff6b6b} .pending{color:#ffd166} .info{color:#7dd3fc}
  .tiny{font-size:.85em;opacity:.8}

  /* ===== Controls + layout ===== */
  .controls{display:flex;justify-content:center;align-items:center;gap:8px;flex-wrap:wrap;margin:12px 0}
  .input-wrapper{position:relative; z-index:4000}
  #cityInput{width:360px;max-width:100%;padding:10px 36px 10px 12px;border-radius:10px;border:2px solid var(--accent);background:#111;color:#00ffc3;font-weight:700;box-shadow:var(--shadow)}
  .btn{background:#7a6cb6;color:#fff;border:none;border-radius:10px;padding:10px 14px;font-weight:700;cursor:pointer;box-shadow:0 0 10px rgba(122,108,182,.5)}
  #suggestions{position:absolute;top:100%;left:0;right:0;background:#121212;border:1px solid var(--border);border-radius:10px;list-style:none;padding:0;margin:6px 0 0 0;display:none;overflow:hidden;z-index:5000}
  #suggestions li{padding:10px 12px;cursor:pointer;color:var(--text)} #suggestions li:hover{background:#243442}

  .top-row{display:grid;grid-template-columns: minmax(300px, 1fr) minmax(280px, 1fr);gap:16px;align-items:start}
  .left-col{display:flex;flex-direction:column;gap:16px}
  .right-col{position:relative}

  .panel{background:rgba(15,23,42,0.55);border:1px solid rgba(255,255,255,0.10);border-radius:14px;padding:14px;box-shadow:0 10px 24px rgba(0,0,0,.35);backdrop-filter:saturate(140%) blur(6px)}
  .panel strong{color:var(--accent)}
  .kv{display:grid;grid-template-columns:max-content 1fr;gap:6px 10px}

  /* === Modern info panels (Location + Astronomy) === */
  .info-panel{
    position:relative;
    overflow:hidden;
    border-radius:16px;
    border:1px solid rgba(255,255,255,0.10);
    background:
      radial-gradient(900px 220px at 0% 0%, rgba(0,255,195,0.10), transparent 60%),
      radial-gradient(700px 200px at 100% 20%, rgba(124,58,237,0.10), transparent 60%),
      rgba(15,23,42,0.50);
    box-shadow:0 14px 32px rgba(0,0,0,.45);
    backdrop-filter:saturate(140%) blur(6px);
  }
  .info-panel::before{
    content:'';
    position:absolute; inset:-1px;
    background:radial-gradient(600px 160px at 50% 0%, rgba(0,255,195,0.16), transparent 70%);
    pointer-events:none;
  }
  .info-panel .panel-head{
    display:flex;
    align-items:center;
    gap:10px;
    padding:2px 2px 10px;
    margin-bottom:10px;
    border-bottom:1px solid rgba(255,255,255,0.08);
    position:relative;
    z-index:1;
  }
  .info-panel .panel-icon{
    width:28px;
    height:28px;
    display:inline-flex;
    align-items:center;
    justify-content:center;
    border-radius:999px;
    background:rgba(0,0,0,0.22);
    border:1px solid rgba(255,255,255,0.12);
    box-shadow:0 0 14px rgba(0,255,195,.10);
  }
  .info-panel .panel-title{
    font-family:'Orbitron','Inter',system-ui,sans-serif;
    letter-spacing:.06em;
    font-weight:600;
    color:#fff;
  }
  .info-panel .kv{position:relative; z-index:1;}
  .info-panel .kv strong{color:rgba(255,255,255,0.72); font-weight:700;}
  .info-panel .kv span{color:rgba(255,255,255,0.92);}
  .accent-text{color:var(--accent); font-weight:700;}
  .bortle-link{
    display:inline-flex;
    align-items:center;
    gap:8px;
    padding:4px 10px;
    border-radius:999px;
    background:rgba(0,0,0,0.22);
    border:1px solid rgba(255,255,255,0.12);
    color:#fff;
    text-decoration:none;
    font-weight:800;
    transition:filter .12s ease, transform .08s ease;
  }
  .bortle-link:hover{filter:brightness(1.18)}
  .bortle-link:active{transform:translateY(1px)}
  .info-rows{position:relative; z-index:1; margin-top:6px;}
  .info-rows strong{color:rgba(255,255,255,0.72); font-weight:700;}
  .info-rows .small strong{color:rgba(255,255,255,0.72);}


  /* === Modern info panels (Location + Astronomy) === */
  .info-panel{
    position:relative;
    overflow:hidden;
    border-radius:16px;
    border:1px solid rgba(255,255,255,0.10);
    background:
      radial-gradient(900px 220px at 0% 0%, rgba(0,255,195,0.10), transparent 60%),
      radial-gradient(700px 200px at 100% 20%, rgba(124,58,237,0.10), transparent 60%),
      rgba(15,23,42,0.50);
    box-shadow:0 12px 28px rgba(0,0,0,.42);
    backdrop-filter:saturate(150%) blur(8px);
  }
  .info-panel::before{
    content:"";
    position:absolute; inset:0;
    background:radial-gradient(600px 160px at 50% 0%, rgba(0,255,195,0.10), transparent 70%);
    pointer-events:none;
  }
  .info-panel .panel-head{
    display:flex;
    align-items:center;
    gap:10px;
    padding:2px 0 10px;
    border-bottom:1px solid rgba(255,255,255,0.06);
    position:relative;
    z-index:1;
  }
  .info-panel .panel-icon{
    width:26px;
    height:26px;
    display:inline-flex;
    align-items:center;
    justify-content:center;
    border-radius:10px;
    background:rgba(255,255,255,0.08);
    border:1px solid rgba(255,255,255,0.10);
    box-shadow:0 8px 18px rgba(0,0,0,.22);
  }
  .info-panel .panel-title{
    font-family:"Orbitron", "Inter", system-ui, sans-serif;
    letter-spacing:.06em;
    font-weight:650;
    color:#fff;
  }
  .info-panel .kv{
    position:relative;
    z-index:1;
    gap:8px 14px;
  }
  .info-panel .kv strong{
    color:rgba(255,255,255,0.78);
    font-weight:700;
  }
  .info-panel .kv span{
    color:rgba(255,255,255,0.92);
  }
  .accent-text{
    color:var(--accent);
    font-weight:750;
  }
  .bortle-link{
    display:inline-flex;
    align-items:center;
    gap:8px;
    padding:5px 10px;
    border-radius:999px;
    border:1px solid rgba(255,255,255,0.12);
    background:rgba(0,0,0,0.22);
    color:#fff;
    text-decoration:none;
    font-weight:800;
    font-size:.88rem;
    transition:filter .12s ease, transform .08s ease, background .12s ease;
  }
  .bortle-link:hover{filter:brightness(1.15)}
  .bortle-link:active{transform:translateY(1px)}


  /* === Modern info panels (Location + Astronomy) === */
  .info-panel{
    background:
      radial-gradient(900px 220px at 0% 0%, rgba(0,255,195,0.10), transparent 60%),
      radial-gradient(700px 200px at 100% 20%, rgba(124,58,237,0.10), transparent 60%),
      rgba(15,23,42,0.50);
  }
  .info-panel .panel-head{
    display:flex;
    align-items:center;
    gap:10px;
    padding:2px 2px 10px;
    margin:-2px -2px 10px;
    border-bottom:1px solid rgba(255,255,255,0.08);
  }
  .info-panel .panel-icon{
    width:28px;height:28px;
    display:grid;place-items:center;
    border-radius:10px;
    background:rgba(0,0,0,0.22);
    border:1px solid rgba(255,255,255,0.12);
    box-shadow:0 6px 16px rgba(0,0,0,0.25);
  }
  .info-panel .panel-title{
    font-family:'Orbitron', 'Inter', system-ui, sans-serif;
    letter-spacing:.06em;
    font-weight:600;
    color:#fff;
  }
  .info-panel .kv{
    gap:8px 12px;
  }
  .info-panel .kv span:nth-child(odd) strong{
    color:rgba(255,255,255,0.70);
    font-weight:700;
  }
  .info-panel .kv span:nth-child(even){
    color:rgba(255,255,255,0.92);
  }
  .accent-text{
    color:var(--accent);
    font-weight:800;
  }
  .bortle-link{
    display:inline-flex;
    align-items:center;
    gap:6px;
    padding:4px 10px;
    border-radius:999px;
    border:1px solid rgba(255,255,255,0.12);
    background:rgba(0,0,0,0.22);
    color:#fff;
    text-decoration:none;
    font-weight:800;
    box-shadow:0 8px 18px rgba(0,0,0,0.25);
  }
  .bortle-link:hover{
    filter:brightness(1.12);
  }

  /* === Modern info panels (Location + Astronomy) === */
  .info-panel{
    background:radial-gradient(900px 220px at 0% 0%, rgba(0,255,195,0.10), transparent 60%),
               radial-gradient(700px 200px at 100% 20%, rgba(124,58,237,0.10), transparent 60%),
               rgba(15,23,42,0.50);
    border:1px solid rgba(255,255,255,0.10);
    border-radius:16px;
    padding:14px 14px 12px;
  }
  .info-panel .panel-head{
    display:flex;
    align-items:center;
    gap:10px;
    padding-bottom:10px;
    margin-bottom:10px;
    border-bottom:1px solid rgba(255,255,255,0.08);
  }
  .info-panel .panel-icon{
    width:28px; height:28px;
    display:grid; place-items:center;
    border-radius:10px;
    background:rgba(255,255,255,0.06);
    border:1px solid rgba(255,255,255,0.10);
    box-shadow:0 0 16px rgba(0,0,0,0.25);
  }
  .info-panel .panel-title{
    font-family:"Orbitron", "Inter", system-ui, sans-serif;
    letter-spacing:.05em;
    font-weight:600;
    color:#fff;
    text-transform:uppercase;
    font-size:0.98rem;
  }
  .info-panel .kv{
    gap:8px 12px;
  }
  .info-panel .kv strong{
    color:rgba(255,255,255,0.78);
    font-weight:700;
  }
  .info-panel .kv span:nth-child(2n){
    color:rgba(255,255,255,0.95);
  }
  .accent-text{
    color:var(--accent);
    font-weight:800;
  }
  .bortle-link{
    display:inline-flex;
    align-items:center;
    gap:8px;
    padding:4px 10px;
    border-radius:999px;
    border:1px solid rgba(255,255,255,0.14);
    background:rgba(0,0,0,0.22);
    color:#fff;
    text-decoration:none;
    font-weight:800;
    box-shadow:0 0 14px rgba(0,255,195,0.18);
  }
  .bortle-link:hover{
    filter:brightness(1.15);
  }

  #mapPanel{padding:0;overflow:hidden;position:relative; z-index:1; aspect-ratio: 1 / 1;}
  #map{width:100%;height:100%}
  
  /* === P≈ôesunut√≠ a zmen≈°en√≠ kontrolu vrstev (o 30% dol≈Ø/doprava) === */
  .leaflet-control-container .leaflet-control-layers {
    transform: scale(0.7);
    transform-origin: bottom right; 
    margin-right: 8px; 
    margin-bottom: 8px; 
  }
  
  .zoom-badge{position:absolute;top:8px;left:8px;background:rgba(0,0,0,0.55);color:#fff;padding:4px 8px;border-radius:999px;font-size:.85em;border:1px solid rgba(255,255,255,.2);z-index:2}
  .map-tip{position:absolute;bottom:8px;left:8px;background:rgba(0,0,0,0.55);color:#fff;padding:6px 8px;border-radius:8px;font-size:.9em;border:1px solid rgba(255,255,255,.2);z-index:2}

  /* === Modern forecast day cards (match astro widgets) === */
  .forecast-day{
    position:relative;
    overflow:hidden;
    border-radius:14px;
    border:1px solid rgba(255,255,255,0.10);
    background:radial-gradient(circle at top, #111827 0%, #020617 72%);
    box-shadow:0 10px 24px rgba(0,0,0,.45);
  }
  .forecast-day::before{
    content:'';
    position:absolute; inset:0;
    background:radial-gradient(600px 180px at 50% 0%, rgba(0,255,195,0.10), transparent 70%);
    pointer-events:none;
  }
  .forecast-day h3{
    margin:0;
    padding:12px 12px 10px;
    background:linear-gradient(180deg, rgba(0,0,0,0.18) 0%, rgba(0,0,0,0) 100%);
    color:#fff;
    display:flex;
    align-items:center;
    gap:10px;
    position:relative;
    z-index:2;
    flex-wrap:wrap;
    border-bottom:1px solid rgba(255,255,255,0.06);
  }
  .forecast-day h3 .day-title{
    font-family:'Orbitron', 'Inter', system-ui, sans-serif;
    letter-spacing:.06em;
    font-weight:600;
    font-size:1.05rem;
  }
  .forecast-day h3 .day-sub{
    font-size:.85rem;
    opacity:.85;
    padding:2px 8px;
    border-radius:999px;
    border:1px solid rgba(255,255,255,0.12);
    background:rgba(0,0,0,0.22);
  }

  .day-actions{display:inline-flex; gap:6px; align-items:center; flex-wrap:wrap}
  .mini-btn{
    background:rgba(0,0,0,0.22);
    color:#fff;
    border:1px solid rgba(255,255,255,0.12);
    border-radius:999px;
    padding:4px 10px;
    font-weight:700;
    font-size:.82rem;
    cursor:pointer;
    transition:filter .12s ease, transform .08s ease;
  }
  .mini-btn:hover{filter:brightness(1.18)}
  .mini-btn:active{transform:translateY(1px)}

  .mode-tabs{display:flex; gap:6px; margin-left:auto}
  .mode-btn{
    background:rgba(255,255,255,0.08);
    color:#fff;
    border:1px solid rgba(255,255,255,0.12);
    border-radius:999px;
    padding:6px 10px;
    cursor:pointer;
    font-weight:800;
    font-size:.9em;
    letter-spacing:.02em;
    transition:transform .08s ease, filter .12s ease, background .12s ease;
  }
  .mode-btn:active{transform:translateY(1px)}
  .mode-btn.active{
    background:var(--accent);
    color:#000;
    border-color:rgba(0,0,0,0.12);
    box-shadow:0 0 14px rgba(0,255,195,.35);
  }
  .mode-btn:hover{filter:brightness(1.12)}
  .tiny-help{font-size:.85em;opacity:.78;margin-left:6px}

  .forecast-content{display:none;padding:12px;position:relative}
  .forecast-scroll-wrapper{position:relative; overflow:hidden;}
  .forecast-scroll{
    position:relative;
    display:flex;
    gap:10px;
    overflow-x:auto;
    overflow-y:hidden;
    padding:8px 2px 4px;
    z-index:2;
    scroll-behavior:smooth;
  }
  .bg-graph{position:absolute;top:0;left:0;z-index:1;pointer-events:none; opacity:.95;}
  .forecast-card{
    min-width:86px;
    font-size:.92em;
    background:rgba(15,23,42,0.55);
    border:1px solid rgba(255,255,255,0.10);
    border-radius:12px;
    padding:8px 8px 7px;
    text-align:center;
    position:relative;
    z-index:2;
    box-shadow:0 8px 18px rgba(0,0,0,.25);
    backdrop-filter:saturate(140%) blur(4px);
  }
  .forecast-card .t{font-weight:800; letter-spacing:.02em;}
  .forecast-card .v{opacity:.92;}
  .scroll-left,.scroll-right{background:none;border:none;color:#fff;font-size:1.5em;padding:6px 10px;cursor:pointer;position:absolute;top:50%;transform:translateY(-50%);opacity:.6;text-shadow:0 0 6px rgba(255,255,255,.3);z-index:3}
  .scroll-left{left:6px}.scroll-right{right:6px}
  .spinner{display:none;width:44px;height:44px;margin:8px auto;border:6px solid #333;border-top:6px solid var(--accent);border-radius:50%;animation:spin 1s linear infinite}
  @keyframes spin{100%{transform:rotate(360deg)}}
  .footer{text-align:center;opacity:.8;margin-top:10px;font-size:.95em}
  .small{font-size:.92em;opacity:.9}
  .pill{display:inline-block;padding:2px 8px;border-radius:999px;background:#243442;border:1px solid var(--border);margin:4px 6px 0 0}

  /* Glob√°ln√≠ p≈ôep√≠naƒçe v topbaru ‚Äì skryt√© do vyhled√°n√≠ lokace */
  .global-mode-tabs{ display:none; }
  .global-mode-tabs.shown{ display:flex; }


  /* === Astro widget (Slunce / Mƒõs√≠c) === */
  .astro-widget{
    margin-top:10px;
  }
  .astro-widget-row{
    display:flex;
    flex-wrap:wrap;
    gap:10px;
  }
  .astro-card{
    flex:1 1 160px;
    background:radial-gradient(circle at top, #111827 0%, #020617 70%);
    border-radius:12px;
    padding:10px 12px;
    border:1px solid rgba(255,255,255,0.08);
    box-shadow:0 0 14px rgba(0,0,0,.7);
  }
  .astro-card-header{
    display:flex;
    justify-content:space-between;
    align-items:center;
    margin-bottom:4px;
  }
  .astro-card-title{
    font-size:.8rem;
    letter-spacing:.18em;
    text-transform:uppercase;
    font-weight:700;
    color:var(--accent);
  }
  .astro-info-icon{
    width:18px;height:18px;border-radius:999px;
    border:1px solid rgba(255,255,255,0.35);
    display:flex;align-items:center;justify-content:center;
    font-size:.7rem;opacity:.7;
  }
  .astro-arc-wrapper{
    margin-top:6px;
    margin-bottom:4px;
  }
  .astro-arc-wrapper svg{
    width:100%;
    height:90px;
  }
  .astro-baseline{
    stroke:rgba(255,255,255,0.35);
    stroke-width:1.2;
  }
  .astro-sun-above{
    fill:none;
    stroke-width:2.2;
    stroke-linecap:round;
    stroke:#fbbf24;
  }
  .astro-sun-below{
    fill:none;
    stroke-width:1.6;
    stroke-linecap:round;
    stroke:rgba(248,250,252,0.25);
  }
  .astro-moon-above{
    fill:none;
    stroke-width:2.2;
    stroke-linecap:round;
    stroke:#cbd5f5;
  }
  .astro-moon-below{
    fill:none;
    stroke-width:1.6;
    stroke-linecap:round;
    stroke:rgba(148,163,184,0.4);
  }
  .astro-sun-dot{
    fill:#fde68a;
    stroke:#fbbf24;
    stroke-width:2;
    filter:drop-shadow(0 0 8px rgba(251,191,36,0.9));
  }
  .astro-moon-dot{
    fill:#e5e7eb;
    stroke:#9ca3af;
    stroke-width:2;
    filter:drop-shadow(0 0 6px rgba(148,163,184,0.9));
  }
  .astro-times{
    display:flex;
    justify-content:space-between;
    gap:8px;
    font-size:.78rem;
    color:#e5e7eb;
  }
  .astro-times strong{
    color:var(--accent);
  }
  .astro-alt{
    margin-top:2px;
    font-size:.72rem;
    color:#9ca3af;
    text-align:right;
  }

</style>

<style>
.astro-static{ user-select:text; }

/* === Mobile-first vylep≈°en√≠ (‚â§ 768px) === */
@media (max-width: 768px){
  :root{
    --safe-top: env(safe-area-inset-top);
    --safe-bottom: env(safe-area-inset-bottom);
  }

  body{ padding:8px; padding-bottom: calc(12px + var(--safe-bottom)); }
  h1{ font-size:1.5rem; margin:6px 0 10px; }

  .topbar{
    padding:6px 8px;
    padding-top: calc(6px + var(--safe-top));
    gap:6px;
    grid-template-columns:auto 1fr auto;
  }
  .now-status{
    flex-wrap:wrap;
    row-gap:4px;
    font-size:.95em;
  }

  .controls{ gap:6px; }
  #cityInput{
    width:100%;
    font-size:16px;           /* iOS no-zoom */
    padding:12px 38px 12px 12px;
  }
  #suggestions{ max-height:50vh; overflow:auto; }

  .top-row{ grid-template-columns: 1fr; }
  .panel{ padding:12px; }

  /* Mapa na mobilu: v≈ædy ƒçtverec (stejn√° ≈°√≠≈ôka i v√Ω≈°ka) */
  #mapPanel{ aspect-ratio: 1 / 1 !important; height:auto !important; }
  #map{ height:100% !important; }

  .forecast-scroll{
    -webkit-overflow-scrolling: touch;
    padding-bottom:10px;
  }
  .forecast-card{ min-width:96px; padding:8px; }
  .scroll-left, .scroll-right{ display:none; }

  .mode-tabs{ flex-wrap:wrap; }
}
</style>

<style>
/* === Planet visibility widget (integrated) === */
#planet-widget{
  --pw-bg: rgba(0,0,0,.14);
  --pw-line: rgba(255,255,255,.10);
  --pw-text: #e8ecff;
  --pw-muted: #aab2d6;
  --pw-good:#8af0a4;
  --pw-warn:#ffd36a;
  --pw-bad:#ff7a7a;
  --pw-shadow: 0 14px 38px rgba(0,0,0,.35);
  --pw-radius: 14px;
  --pw-mono: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
}
#planet-widget .pw-panel{
  margin-top:12px;
  background: rgba(0,0,0,.12);
  border:1px solid var(--pw-line);
  border-radius: 12px;
  box-shadow: 0 8px 20px rgba(0,0,0,.35);
  overflow:hidden;
}
#planet-widget .pw-hdr{
  padding: 12px 12px 10px 12px;
  display:flex;
  gap:10px;
  align-items:flex-start;
  justify-content:space-between;
  border-bottom:1px solid var(--pw-line);
  background: rgba(0,0,0,.10);
}
#planet-widget .pw-title{
  display:flex; gap:8px; align-items:center; flex-wrap:wrap;
}
#planet-widget .pw-title h2{
  margin:0;
  font-size: 14px;
  letter-spacing:.2px;
  color:#fff;
}
#planet-widget .pw-badge{
  display:inline-flex;
  align-items:center;
  gap:8px;
  padding: 6px 9px;
  border-radius: 999px;
  background: rgba(255,255,255,.06);
  border:1px solid var(--pw-line);
  color: var(--pw-muted);
  font-size: 12px;
  white-space: nowrap;
}
#planet-widget .pw-sub{
  margin-top:4px;
  font-size: 12px;
  color: var(--pw-muted);
  line-height:1.35;
}
#planet-widget .pw-controls{
  display:flex;
  flex-wrap:wrap;
  gap:8px;
  align-items:center;
  justify-content:flex-end;
}
#planet-widget .pw-controls label{
  display:flex;
  gap:8px;
  align-items:center;
  color: var(--pw-muted);
  font-size: 12px;
  user-select:none;
}
#planet-widget .pw-body{ padding: 10px 12px 12px 12px; }
#planet-widget .pw-statusRow{
  display:flex;
  flex-wrap:wrap;
  gap:10px;
  align-items:center;
  justify-content:space-between;
  margin-bottom: 10px;
}
#planet-widget .pw-status{
  font-family: var(--pw-mono);
  font-size: 11px;
  color: var(--pw-muted);
}
#planet-widget .pw-grid{
  display:grid;
  grid-template-columns: repeat(2, minmax(0, 1fr));
  gap: 10px;
}
@media (max-width: 768px){
  #planet-widget .pw-grid{ grid-template-columns: 1fr; }
  #planet-widget .pw-controls{ justify-content:flex-start; }
}

#planet-widget .pw-card{
  background: rgba(0,0,0,.14);
  border:1px solid var(--pw-line);
  border-radius: 12px;
  padding: 10px;
  overflow:hidden;
}
#planet-widget .pw-rowTop{
  display:flex;
  align-items:center;
  justify-content:space-between;
  gap: 10px;
  margin-bottom: 8px;
}
#planet-widget .pw-planet{
  display:flex;
  align-items:center;
  gap:10px;
  min-width: 0;
}
#planet-widget .pw-icon{
  width: 32px; height: 32px;
  display:grid; place-items:center;
  border-radius: 10px;
  background: rgba(255,255,255,.06);
  border:1px solid var(--pw-line);
  flex: 0 0 auto;
  font-size: 18px;
}
#planet-widget .pw-name{
  display:flex;
  flex-direction:column;
  min-width: 0;
}
#planet-widget .pw-name strong{
  font-size: 14px;
  letter-spacing:.2px;
  white-space:nowrap;
  overflow:hidden;
  text-overflow:ellipsis;
}
#planet-widget .pw-name span{
  color: var(--pw-muted);
  font-size: 11px;
  margin-top: 2px;
  white-space:nowrap;
  overflow:hidden;
  text-overflow:ellipsis;
  display:flex;
  gap:6px;
  align-items:center;
}
#planet-widget .pw-const{
  display:inline-flex;
  gap:6px;
  align-items:center;
}
#planet-widget .pw-chip{
  font-family: var(--pw-mono);
  font-size: 11px;
  padding: 6px 8px;
  border-radius: 999px;
  border:1px solid var(--pw-line);
  background: rgba(255,255,255,.05);
  color: var(--pw-muted);
  white-space:nowrap;
  flex: 0 0 auto;
}
#planet-widget .pw-chip.good{ color: #dfffe8; border-color: rgba(138,240,164,.35); background: rgba(138,240,164,.10); }
#planet-widget .pw-chip.warn{ color: #fff2d0; border-color: rgba(255,211,106,.35); background: rgba(255,211,106,.10); }
#planet-widget .pw-chip.bad{  color: #ffd9d9; border-color: rgba(255,122,122,.35); background: rgba(255,122,122,.10); }

#planet-widget .pw-meter{
  position: relative;
  height: 20px;
  border-radius: 999px;
  border:1px solid var(--pw-line);
  background: linear-gradient(90deg,
    rgba(255,122,122,.20),
    rgba(255,211,106,.18) 40%,
    rgba(138,240,164,.20) 70%);
  overflow:hidden;
}
#planet-widget .pw-meter .horizon{
  position:absolute;
  left: 50%;
  top:0; bottom:0;
  width: 1px;
  background: rgba(255,255,255,.22);
  opacity:.85;
}
#planet-widget .pw-meter .tick{
  position:absolute;
  top:0; bottom:0;
  width: 1px;
  background: rgba(255,255,255,.10);
}
#planet-widget .pw-meter .tick.t1{ left: 25%; }
#planet-widget .pw-meter .tick.t2{ left: 75%; }
#planet-widget .pw-meter .dot{
  position:absolute;
  top: 50%;
  width: 12px;
  height: 12px;
  border-radius: 99px;
  transform: translate(-50%, -50%);
  background: rgba(255,255,255,.92);
  box-shadow: 0 10px 20px rgba(0,0,0,.35);
  border: 2px solid rgba(0,0,0,.35);
}
#planet-widget .pw-meter .dot::after{
  content:"";
  position:absolute;
  inset:-8px;
  border-radius: 999px;
  background: radial-gradient(circle, rgba(255,255,255,.25), transparent 60%);
  pointer-events:none;
}

#planet-widget .pw-meta{
  display:flex;
  gap:8px;
  margin-top: 8px;
  flex-wrap:wrap;
  align-items:center;
  justify-content:space-between;
  color: var(--pw-muted);
  font-size: 11px;
}
#planet-widget .pw-kv{
  display:flex;
  gap:8px;
  align-items:center;
  font-family: var(--pw-mono);
  font-size: 11px;
  padding: 5px 7px;
  border-radius: 12px;
  border:1px solid var(--pw-line);
  background: rgba(255,255,255,.04);
  white-space:nowrap;
}

/* Tooltip */
#planet-widget .pw-tooltip{
  position: relative;
  display: inline-flex;
  align-items: center;
  gap: 8px;
}
#planet-widget [data-tip]{ cursor: help; }
#planet-widget [data-tip]::after{
  content: attr(data-tip);
  position: absolute;
  left: 0;
  top: calc(100% + 10px);
  min-width: 220px;
  max-width: 360px;
  padding: 10px 11px;
  border-radius: 12px;
  background: rgba(12, 18, 38, .96);
  border: 1px solid rgba(255,255,255,.14);
  box-shadow: 0 14px 38px rgba(0,0,0,.38);
  color: #e8ecff;
  font-size: 12px;
  line-height: 1.35;
  opacity: 0;
  pointer-events: none;
  transform: translateY(-4px);
  transition: opacity .12s ease, transform .12s ease;
  z-index: 20;
}
#planet-widget [data-tip]::before{
  content: "";
  position: absolute;
  left: 16px;
  top: calc(100% + 4px);
  width: 0; height: 0;
  border-left: 7px solid transparent;
  border-right: 7px solid transparent;
  border-bottom: 7px solid rgba(12, 18, 38, .96);
  opacity: 0;
  pointer-events: none;
  transform: translateY(-4px);
  transition: opacity .12s ease, transform .12s ease;
  z-index: 21;
}
#planet-widget [data-tip]:hover::after,
#planet-widget [data-tip]:hover::before{
  opacity: 1;
  transform: translateY(0);
}
</style>

</head>
<body>

<div class="layout">
  <aside class="ad-slot">Rezervov√°no pro lev√Ω banner (220px)</aside>

  <main>
    <div class="topbar">
      <div class="menu-container">
        <button class="menu-toggle" onclick="toggleMenu()">üìã Menu</button>
        <div class="menu-dropdown" id="mainMenu">
          <div class="menu-section">
            <div class="menu-item has-submenu">üó∫Ô∏è Mapy ‚ñ∏
              <div class="submenu">
                <a class="menu-link" href="https://www.lightpollutionmap.info" target="_blank">üí° Light Pollution Map</a>
                <a class="menu-link" href="https://www.windy.com" target="_blank">üå¨Ô∏è Windy</a>
              </div>
            </div>
          </div>
          <div class="menu-section">
            <div class="menu-item has-submenu">üõ†Ô∏è N√°stroje ‚ñ∏
              <div class="submenu">
                <a class="menu-link" href="#" id="openDiag">üß™ API diagnostika</a>
              </div>
            </div>
          </div>
          <div class="menu-section">
            <div class="menu-item has-submenu">‚ÑπÔ∏è Verze ‚ñ∏
              <div class="submenu">
                <div class="menu-item" id="versionInMenuRow">Aktu√°ln√≠: <strong id="versionInMenu">‚Äî</strong></div>
              </div>
            </div>
          </div>
        </div>
      </div>

      <div id="nowStatus" class="now-status" style="display:none">
        <span class="place" id="nowPlace">‚Äî</span><span class="sep">|</span>
        <span>üëÅÔ∏è <span class="val" id="nowSeeing">‚Äî</span></span>
        <span class="sep">‚Ä¢</span>
        <span>üí® <span class="val" id="nowWind">‚Äî</span></span>
        <span class="sep">‚Ä¢</span>
        <span>üåßÔ∏è <span class="val" id="nowRain">‚Äî</span></span>
        <span class="sep">‚Ä¢</span>
        <span>üå°Ô∏è <span class="val" id="nowTemp">‚Äî</span></span>
      </div>

      
<div id="globalModeTabs" class="global-mode-tabs" style="gap:6px;align-items:center;">
  <button class="mode-btn" data-mode="seeing" onclick="changeAllGraphModes('seeing')">üëÅÔ∏è</button>
  <button class="mode-btn" data-mode="wind" onclick="changeAllGraphModes('wind')">üí®</button>
  <button class="mode-btn" data-mode="rain" onclick="changeAllGraphModes('rain')">üåßÔ∏è</button>
  <button class="mode-btn" data-mode="temp" onclick="changeAllGraphModes('temp')" title="Teplota">üå°Ô∏è</button>
</div>

    </div>

    <h1>ü™ê Astronomick√° p≈ôedpovƒõƒè</h1>

    <div class="controls">
      <div class="input-wrapper">
        <input id="cityInput" type="text" placeholder="Zadejte mƒõsto..." oninput="autocompleteCities()"/>
        <ul id="suggestions"></ul>
      </div>
      <button class="btn" onclick="getLocation()">üìç Moje poloha</button>
    </div>

    <div class="top-row">
      <div class="left-col" id="leftTop">
        <div class="panel info-panel">
          <div class="panel-head">
            <span class="panel-icon">üìç</span>
            <span class="panel-title">Informace o m√≠stƒõ</span>
          </div>
          <div class="kv" style="margin-top:8px;">
            <span><strong>N√°zev:</strong></span><span id="info-name">‚Äî</span>
            <span><strong>GPS:</strong></span><span id="info-gps">‚Äî</span>
            <span><strong>M√≠stn√≠ ƒças:</strong></span><span id="info-localtime">‚Äî</span>
            <span><strong>Mapa LP:</strong></span><span><a id="bortle-link" class="bortle-link" href="#" target="_blank" style="display:none">Zobrazit Bortle</a></span>
          </div>
        </div>

        <div class="panel info-panel">
          <div class="panel-head">
            <span class="panel-icon">üî≠</span>
            <span class="panel-title">Astronomick√© informace</span>
          </div>

          <div class="info-rows">
            <div><strong>üåï F√°ze Mƒõs√≠ce:</strong> <span id="moon-phase-label">‚Äî</span></div>
            <div class="small" style="margin-top:4px;"><strong>‚ú® Osvƒõtlen√≠ Mƒõs√≠ce:</strong> <span id="moon-illum-label">‚Äî</span></div>
            <div class="small" style="margin-top:6px;"><strong>üåå Pozorov√°n√≠ hvƒõzd (nautick√° noc):</strong> <span id="nautical-night-label">‚Äî</span></div>
            <div class="small"><strong>üñ§ √öpln√° tma (astronomick√° noc):</strong> <span id="astro-night-label">‚Äî</span></div>
            <div class="tiny" style="margin-top:4px;opacity:.75;">Datum: <span id="astro-night-date">‚Äî</span></div>

          </div>

          <!-- NOV√ù WIDGET: Slunce & Mƒõs√≠c -->
          <div class="astro-widget">
            <div class="astro-widget-row">

              <!-- SLUNCE -->
              <div class="astro-card">
                <div class="astro-card-header">
                  <span class="astro-card-title">SLUNCE</span>
                  <span class="astro-info-icon">i</span>
                </div>
                <div class="astro-arc-wrapper">
                  <svg viewBox="0 0 300 90">
                    <line x1="20" y1="45" x2="280" y2="45" class="astro-baseline"></line>

                    <path id="sun-path-above" class="astro-sun-above" d=""></path>
                    <path id="sun-path-below" class="astro-sun-below" d=""></path>

                    <!-- vƒõt≈°√≠ Slunce -->
                    <circle id="sun-dot" class="astro-sun-dot" r="10" cx="20" cy="45"></circle>
                  </svg>
                </div>
                <div class="astro-times">
                  <span>V√Ωchod: <strong id="sun-rise-label">‚Äî</strong></span>
                  <span>Z√°pad: <strong id="sun-set-label">‚Äî</strong></span>
                </div>
                <div class="astro-alt" id="sun-alt-label">V√Ω≈°ka: ‚Äî</div>
              </div>

              <!-- MƒöS√çC -->
              <div class="astro-card">
                <div class="astro-card-header">
                  <span class="astro-card-title">MƒöS√çC</span>
                  <span class="astro-info-icon">i</span>
                </div>
                <div class="astro-arc-wrapper">
                  <svg viewBox="0 0 300 90">
                    <line x1="20" y1="45" x2="280" y2="45" class="astro-baseline"></line>

                    <path id="moon-path-above" class="astro-moon-above" d=""></path>
                    <path id="moon-path-below" class="astro-moon-below" d=""></path>

                    <!-- vƒõt≈°√≠ Mƒõs√≠c -->
                    <circle id="moon-dot" class="astro-moon-dot" r="9" cx="20" cy="45"></circle>
                  </svg>
                </div>
                <div class="astro-times">
                  <span>V√Ωchod: <strong id="moon-rise-label">‚Äî</strong></span>
                  <span>Z√°pad: <strong id="moon-set-label">‚Äî</strong></span>
                </div>
                <div class="astro-alt" id="moon-alt-label">V√Ω≈°ka: ‚Äî</div>
              </div>

            </div>
          </div>


          <!-- NOV√ù WIDGET: Viditelnost planet -->
          <div id="planet-widget" class="astro-widget">
            <div class="pw-panel">
              <div class="pw-hdr">
                <div style="min-width:0">
                  <div class="pw-title">
                    <h2>ü™ê Viditelnost planet</h2>
                    <span class="pw-badge" id="pw-observer-label">Pozorovatel: Praha</span>
                    <span class="pw-tooltip">
                      <span class="astro-info-icon" data-tip="Planety nad/pod obzorem pro zadan√© sou≈ôadnice. Hodnocen√≠ je orientaƒçn√≠: v√Ω≈°ka nad obzorem + jasnost (magnituda). Data: api.visibleplanets.dev.">i</span>
                    </span>
                  </div>
                  <div class="pw-sub">Planety se aktualizuj√≠ po vyhled√°n√≠ m√≠sta (pou≈æ√≠v√° stejn√© sou≈ôadnice jako Slunce/Mƒõs√≠c).</div>
                </div>
                <div class="pw-controls">
                  <label title="Zobrazit i objekty pod obzorem">
                    <input type="checkbox" id="pw-show-below" />
                    uk√°zat i pod obzorem
                  </label>
                </div>
              </div>

              <div class="pw-body">
                <div class="pw-statusRow">
                  <div class="pw-status" id="pw-status">P≈ôipraveno.</div>
                  <div class="pw-status" id="pw-meta"></div>
                </div>

                <div class="pw-grid" id="pw-grid"></div>
              </div>
            </div>
          </div>

                  </div>
      </div>

      <div class="right-col">
        <div class="panel" id="mapPanel">
          <div id="map"></div>
          <div id="mapZoomBadge" class="zoom-badge">Zoom: vypnuto</div>
          <div class="map-tip">Klikni <b>prav√Ωm</b> na mapu pro zapnut√≠/vypnut√≠ zoomu</div>
        </div>
      </div>
    </div>

    <div class="spinner" id="spinner" style="margin-top:16px;"></div>
    <div id="forecast" style="margin-top:8px;"></div>

    <div class="footer">
      Zdroj f√°z√≠: ipgeolocation.io ‚Ä¢ Poƒças√≠ a geok√≥dov√°n√≠: Open-Meteo ‚Ä¢ Mapa: Leaflet & OSM/Esri
    </div>
  </main>

  <aside class="ad-slot">Rezervov√°no pro prav√Ω banner (220px)</aside>
</div>

<div class="modal-overlay" id="diagOverlay" role="dialog" aria-modal="true" aria-labelledby="diagTitle">
  <div class="modal">
    <header>
      <h2 id="diagTitle">üß™ API diagnostika</h2>
      <div>
        <button class="btn" id="rerunDiag" title="Spustit znovu">Spustit znovu</button>
        <button class="close-btn" id="closeDiag">Zav≈ô√≠t</button>
      </div>
    </header>
    <div class="tiny" style="margin-bottom:6px;">P≈ôi otev≈ôen√≠ se spust√≠ test, tlaƒç√≠tkem ‚ÄûSpustit znovu‚Äú lze opakovat.</div>
    <div id="diagList"></div>
  </div>
</div>

<script>
const IPGEO_API_KEY="781aa2d69af74745906e01cc68c84207";
const VERSION = "v 0.1"; // <--- ZMƒöNA
/* ===== Menu ===== */
function toggleMenu(){const m=document.getElementById("mainMenu");m.style.display=m.style.display==="block"?"none":"block"}
document.addEventListener("click",(e)=>{const m=document.getElementById("mainMenu");const t=document.querySelector(".menu-toggle");if(m&&t&&!m.contains(e.target)&&!t.contains(e.target))m.style.display="none"});

/* Po naƒçten√≠: doplnit verzi do menu + tooltip na tlaƒç√≠tko */
window.addEventListener('DOMContentLoaded', ()=>{
  const vSpan = document.getElementById('versionInMenu');
  if(vSpan) vSpan.textContent = VERSION;
  const btn = document.querySelector('.menu-toggle');
  if(btn) btn.title = `Verze ${VERSION}`;
});

/* ===== Helpers ===== */
const $=(id)=>document.getElementById(id);
function showSpinner(b){$("spinner").style.display=b?"block":"none"}
function getDayName(d){const today=new Date().toLocaleDateString('en-CA',{timeZone:'Europe/Prague'});if(d===today)return"Dnes";const arr=['Nedƒõle','Pondƒõl√≠','√öter√Ω','St≈ôeda','ƒåtvrtek','P√°tek','Sobota'];return arr[new Date(d+'T00:00:00').getDay()]}
function getWeatherIcon(c,r){
  if(r>2)return'üåßÔ∏è';
  if(r>0)return'üå¶Ô∏è';
  if(c>75)return'‚òÅÔ∏è';
  if(c>25)return'üå§Ô∏è';
  return'‚òÄÔ∏è';
}

/* ===== Layout sync ===== */
function syncMapHeight(){
  // Keep the map always square: height = current width of the map panel
  const mapPanel=document.getElementById("mapPanel");
  const mapDiv=document.getElementById("map");
  if(!mapPanel||!mapDiv) return;

  // If CSS aspect-ratio is supported, this is mostly a safeguard + Leaflet resize trigger.
  const w = mapPanel.getBoundingClientRect().width;
  if(!Number.isFinite(w) || w <= 0) return;

  mapPanel.style.height = w + "px";
  mapDiv.style.height   = w + "px";

  if(window._leafletMap){ setTimeout(()=> window._leafletMap.invalidateSize(), 100); }
}
const leftObserver = new MutationObserver(()=> syncMapHeight());
leftObserver.observe(document.getElementById("leftTop"), {subtree:true, childList:true, characterData:true});
window.addEventListener("resize", syncMapHeight);

/* ===== Geocoding & selection ===== */
let selectedCity=null;
let _acTimer = null;
async function autocompleteCities(){
  const v = $("cityInput").value.trim();
  const s = $("suggestions");
  if(_acTimer) clearTimeout(_acTimer);

  if(v.length < 2){
    s.style.display = "none";
    return;
  }

  // debounce to reduce API calls while typing
  _acTimer = setTimeout(async ()=>{
    try{
      const res = await fetch(`https://geocoding-api.open-meteo.com/v1/search?name=${encodeURIComponent(v)}&count=6&language=cs&format=json`);
      const data = await res.json();
      s.innerHTML = "";
      (data.results||[]).forEach(c=>{
        const li=document.createElement("li");
        li.textContent=`${c.name}, ${c.country}`;
        li.onclick=()=>{
          selectedCity=c;
          $("cityInput").value=`${c.name}, ${c.country}`;
          updateLocationInfo(c);
          initMap(c.latitude,c.longitude);
          fetchForecast(c.latitude,c.longitude);
          fetchMoonPhase(c.latitude,c.longitude);
          window.__lastObserverLatLon = {lat:c.latitude, lon:c.longitude};
          if(window.setObserverLocation){ window.setObserverLocation(c.latitude, c.longitude, c.name); }
          showGlobalTabs(true);
          s.style.display="none";
        };
        s.appendChild(li);
      });
      s.style.display = s.children.length ? "block" : "none";
    }catch(e){
      console.warn("Autocomplete failed", e);
      s.style.display = "none";
    }
  }, 220);
}


async function getLocation(){
  if(!navigator.geolocation)return alert("V√°≈° prohl√≠≈æeƒç nepodporuje geolokaci.");
  navigator.geolocation.getCurrentPosition(async p=>{
    const lat=p.coords.latitude,lon=p.coords.longitude;
    const name=await reverseGeocode(lat,lon);
    const c={name,country:"",latitude:lat,longitude:lon};
    selectedCity=c;
    updateLocationInfo(c);
    initMap(lat,lon);
    fetchForecast(lat,lon);
    fetchMoonPhase(lat,lon);
    window.__lastObserverLatLon = {lat:lat, lon:lon};
    if(window.setObserverLocation){ window.setObserverLocation(lat, lon, name || 'Moje poloha'); }
    showGlobalTabs(true);
    /* NOVƒö: po kliknut√≠ na Moje poloha vyƒçistit vstup i n√°vrhy */
    const input=$("cityInput"); if(input) input.value="";
    const s=$("suggestions"); if(s) { s.innerHTML=""; s.style.display="none"; }
  },e=>alert("Nepoda≈ôilo se zjistit polohu."));
}

async function reverseGeocode(lat,lon){try{const r=await fetch(`https://nominatim.openstreetmap.org/reverse?format=json&lat=${lat}&lon=${lon}&zoom=10&addressdetails=1`);const d=await r.json();return d.address?.city||d.address?.town||d.address?.village||d.address?.municipality||d.display_name||`${lat.toFixed(4)}, ${lon.toFixed(4)}`}catch{return `${lat.toFixed(4)}, ${lon.toFixed(4)}`}} 

function updateLocationInfo(c){const name=c.name||"-";const country=c.country||"";const lat=typeof c.latitude==="number"?c.latitude:null;const lon=typeof c.longitude==="number"?c.longitude:null;$("info-name").innerHTML=country?`<span class="accent-text">${name}</span>, ${country}`:`<span class="accent-text">${name}</span>`;$("info-gps").textContent=(lat!=null&&lon!=null)?`${lat.toFixed(4)}, ${lon.toFixed(4)}`:"‚Äî";const link=$("bortle-link");if(lat!=null&&lon!=null){link.href=`https://www.lightpollutionmap.info/#zoom=9&lat=${lat}&lon=${lon}`;link.style.display="inline"}else{link.style.display="none"};const np=$("nowPlace");if(np){np.textContent = name || "‚Äî";}}

/* === NOV√â: Map Layers Definition === */

// Standard OpenStreetMap layer
const osmStandard = L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
  maxZoom: 19,
  attribution: '¬© OpenStreetMap'
});

// Esri World Imagery (Satellite) layer
const esriSat = L.tileLayer('https://server.arcgisonline.com/ArcGIS/rest/services/World_Imagery/MapServer/tile/{z}/{y}/{x}', {
  maxZoom: 19,
  attribution: 'Tiles ¬© Esri ‚Äî Source: Esri, i-cubed, USDA, USGS, AEX, GeoEye, Getmapping, Aerogrid, IGN, IGP, swisstopo, and the GIS User Community'
});

/* ===== Map on the right ===== */
let map=null,marker=null,zoomEnabled=false; // <--- ODSTRANƒöN√ç: zoomControl

// Funkce pro p≈ôid√°n√≠/aktualizaci Leaflet Layer Control
function addLayerControl() {
  if (!map) return;

  // 1. Z√°kladn√≠ mapy pro p≈ôep√≠n√°n√≠
  const baseMaps = {
    "üó∫Ô∏è Standardn√≠ mapa": osmStandard,
    "üõ∞Ô∏è Satelitn√≠ sn√≠mky (Esri)": esriSat
  };

  // 2. P≈ôekryvn√© vrstvy (RainViewer)
  const overlays = {};
  if (rvState.satLayer) overlays['‚òÅÔ∏è Oblaƒçnost (IR)'] = rvState.satLayer;
  if (rvState.radarLayer) overlays['üåßÔ∏è Sr√°≈ækov√Ω radar'] = rvState.radarLayer;

  // Odstranƒõn√≠ st√°vaj√≠c√≠ho kontrolu, pokud existuje
  if (rvState.control) {
    map.removeControl(rvState.control);
  }

  // 3. P≈ôid√°n√≠ nov√©ho kontrolu a zaji≈°tƒõn√≠, ≈æe je aktivn√≠ v√Ωchoz√≠ mapa
  rvState.control = L.control.layers(baseMaps, overlays, { 
    collapsed: false, 
    position: 'bottomright' // <-- P≈ôesunuto do prav√©ho doln√≠ho rohu
  }).addTo(map);

  // Zaji≈°tƒõn√≠, ≈æe je aktivn√≠ alespo≈à jedna z√°kladn√≠ vrstva (v√Ωchoz√≠ OSM)
  if (!map.hasLayer(osmStandard) && !map.hasLayer(esriSat)) {
    osmStandard.addTo(map);
  }
}

function initMap(lat,lon){
  syncMapHeight();
  if(!map){
    map=window._leafletMap = L.map('map', { 
      zoomControl:true, // <--- ZMƒöNA: Zapnut√≠ tlaƒç√≠tek + a - (Leaflet default)
      scrollWheelZoom:false, 
      touchZoom:false, 
      doubleClickZoom:false, 
      boxZoom:false, 
      keyboard:false, 
      dragging:true 
    }).setView([lat,lon],10);
    
    // Zde ji≈æ nep≈ôid√°v√°me jednu mapovou vrstvu, spravuje to addLayerControl
    
    marker=L.marker([lat,lon]).addTo(map);
    map.on('contextmenu', function(){
      zoomEnabled = !zoomEnabled;
      const badge = $("mapZoomBadge");
      if(zoomEnabled){
        map.scrollWheelZoom.enable(); map.touchZoom.enable(); map.doubleClickZoom.enable(); map.boxZoom.enable(); map.keyboard.enable();
        // zoomControl u≈æ nen√≠ manu√°lnƒõ spravov√°n, je trvale zapnut v L.map
        if(badge) badge.textContent = "Zoom: zapnuto";
      } else {
        map.scrollWheelZoom.disable(); map.touchZoom.disable(); map.doubleClickZoom.disable(); map.boxZoom.disable(); map.keyboard.disable();
        // zoomControl u≈æ nen√≠ manu√°lnƒõ spravov√°n, je trvale zapnut v L.map
        if(badge) badge.textContent = "Zoom: vypnuto";
      }
    });
  } else {
    map.setView([lat,lon], 10);
    marker.setLatLng([lat,lon]);
  }
  
  // P≈ôid√°n√≠ kontroly vrstev hned po inicializaci mapy
  addLayerControl();
  
  // inicializace RainViewer p≈ôekryv≈Ø
  enableWeatherLayers();
  setTimeout(()=> { map.invalidateSize(); syncMapHeight(); }, 150);
}

/* ===== Moon phase & Sun/Moon times (ipgeolocation only) ===== */
let moonIllumByDate = {};
function getMoonEmojiFromName(n){n=String(n||"").toLowerCase().replace(/_/g," ").trim();if(n.includes("new moon"))return"üåë Nov";if(n.includes("waxing crescent"))return"üåí Dor≈Østaj√≠c√≠ srpek";if(n.includes("first quarter"))return"üåì Prvn√≠ ƒçtvr≈•";if(n.includes("waxing gibbous"))return"üåî Dor≈Østaj√≠c√≠ mƒõs√≠c";if(n.includes("full moon"))return"üåï √öplnƒõk";if(n.includes("waning gibbous"))return"üåñ Couvaj√≠c√≠ mƒõs√≠c";if(n.includes("last quarter"))return"üåó Posledn√≠ ƒçtvr≈•";if(n.includes("waning crescent"))return"üåò Couvaj√≠c√≠ srpek";return"üåô Nezn√°m√° f√°ze"}

/* ===== Astro widget: Slunce & Mƒõs√≠c (SunCalc) ===== */
const astroState = {
  lat: 50.0755,
  lon: 14.4378
};

/* ===== Astronomick√° noc (nautick√° + astronomick√°) =====
   - "Pozorov√°n√≠ hvƒõzd" = nautick√° noc: Sun < -12¬∞ (nauticalDusk ‚Üí nauticalDawn)
   - "√öpln√° tma"        = astronomick√° noc: Sun < -18¬∞ (night ‚Üí nightEnd)
   ƒåasy jsou v≈ædy v lok√°ln√≠ ƒçasov√© z√≥nƒõ vyhledan√©ho m√≠sta (Open-Meteo timezone=auto).
*/
window.__selectedNightDate = null;

function _pad2(n){ return String(n).padStart(2,'0'); }

function _tzOffsetMinutes(date, tzName){
  // Returns offset minutes such that: dateInTz = dateUTC + offset
  try{
    const dtf = new Intl.DateTimeFormat('en-US', {
      timeZone: tzName,
      year: 'numeric', month: '2-digit', day: '2-digit',
      hour: '2-digit', minute: '2-digit', second: '2-digit',
      hour12: false
    });
    const parts = dtf.formatToParts(date);
    const map = {};
    parts.forEach(p=>{ map[p.type]=p.value; });
    const asUTC = Date.UTC(
      Number(map.year),
      Number(map.month)-1,
      Number(map.day),
      Number(map.hour),
      Number(map.minute),
      Number(map.second)
    );
    return (asUTC - date.getTime()) / 60000;
  }catch(e){
    return 0;
  }
}

function _zonedDate(dateStr, timeStr, tzName){
  // Creates a Date that represents local time (dateStr + timeStr) in tzName.
  // Uses an offset-calc trick (good enough for DST).
  try{
    const [y,m,d] = dateStr.split('-').map(Number);
    const [hh,mm] = timeStr.split(':').map(Number);
    let dt = new Date(Date.UTC(y, m-1, d, hh||0, mm||0, 0));
    const off = _tzOffsetMinutes(dt, tzName);
    dt = new Date(dt.getTime() - off*60000);
    // one more pass to stabilize on DST boundaries
    const off2 = _tzOffsetMinutes(dt, tzName);
    if(Math.abs(off2-off) > 0.1){
      dt = new Date(dt.getTime() - (off2-off)*60000);
    }
    return dt;
  }catch(e){
    return new Date(dateStr + 'T' + timeStr + ':00');
  }
}

function _fmtTime(dateObj, tzName){
  if(!(dateObj instanceof Date) || isNaN(dateObj)) return '‚Äî';
  try{
    return dateObj.toLocaleTimeString('cs-CZ', { hour:'2-digit', minute:'2-digit', hour12:false, timeZone: tzName });
  }catch(e){
    return dateObj.toLocaleTimeString('cs-CZ', { hour:'2-digit', minute:'2-digit', hour12:false });
  }
}

function _minFromHHmm(hhmm){
  const m = String(hhmm||'').match(/^(\d{1,2}):(\d{2})/);
  if(!m) return null;
  const hh = Number(m[1]), mm = Number(m[2]);
  if(!Number.isFinite(hh) || !Number.isFinite(mm)) return null;
  return hh*60 + mm;
}

function getNightWindowsForDate(dateStr, lat, lon){
  if(!window.SunCalc) return null;
  const tzName = window.__lastTzName || 'Europe/Prague';
  // Noon in local TZ avoids sunrise edge cases.
  const noonLocal = _zonedDate(dateStr, '12:00', tzName);
  const t = SunCalc.getTimes(noonLocal, lat, lon);
  return {
    tzName,
    // nautical night (start observing stars)
    nauticalStart: t.nauticalDusk,
    nauticalEnd:   t.nauticalDawn,
    // astronomical night (full dark)
    astroStart:    t.night,
    astroEnd:      t.nightEnd
  };
}

function updateNightInfo(dateStr){
  const lat = astroState.lat, lon = astroState.lon;
  const w = getNightWindowsForDate(dateStr, lat, lon);
  const elN = document.getElementById('nautical-night-label');
  const elA = document.getElementById('astro-night-label');
  const elD = document.getElementById('astro-night-date');
  if(elD) elD.textContent = dateStr || '‚Äî';
  if(!w){
    if(elN) elN.textContent = '‚Äî';
    if(elA) elA.textContent = '‚Äî';
    return;
  }
  const tzName = w.tzName;
  const naut = _fmtTime(w.nauticalStart, tzName) + ' ‚Äì ' + _fmtTime(w.nauticalEnd, tzName);
  const astro = _fmtTime(w.astroStart, tzName) + ' ‚Äì ' + _fmtTime(w.astroEnd, tzName);
  if(elN) elN.textContent = naut;
  if(elA) elA.textContent = astro;
}



const sunDotEl       = document.getElementById("sun-dot");
const moonDotEl      = document.getElementById("moon-dot");
const sunPathAboveEl = document.getElementById("sun-path-above");
const sunPathBelowEl = document.getElementById("sun-path-below");
const moonPathAboveEl= document.getElementById("moon-path-above");
const moonPathBelowEl= document.getElementById("moon-path-below");
const sunAltLabel    = document.getElementById("sun-alt-label");
const moonAltLabel   = document.getElementById("moon-alt-label");

const ASTRO_MIN_X = 20;
const ASTRO_MAX_X = 280;
const ASTRO_BASELINE_Y = 45;
const ASTRO_AMPLITUDE  = 32;
const ASTRO_MS_PER_DAY = 24 * 60 * 60 * 1000;

function astroDayFraction(date){
  const midnight = new Date(date);
  midnight.setHours(0,0,0,0);
  return (date - midnight) / ASTRO_MS_PER_DAY;
}

// pro Mƒõs√≠c ‚Äì p≈Ølnoc doprost≈ôed
function astroNightFractionCentered(date){
  const midnight = new Date(date);
  midnight.setHours(0,0,0,0);
  const msFromMidnight = date - midnight;
  const shifted = (msFromMidnight + ASTRO_MS_PER_DAY/2) % ASTRO_MS_PER_DAY;
  return shifted / ASTRO_MS_PER_DAY; // 0.5 = p≈Ølnoc
}

function astroAltitudeToPoint(t, altitude){
  const altClamped = Math.max(-Math.PI/2, Math.min(Math.PI/2, altitude));
  const x = ASTRO_MIN_X + t * (ASTRO_MAX_X - ASTRO_MIN_X);
  const y = ASTRO_BASELINE_Y - (altClamped / (Math.PI/2)) * ASTRO_AMPLITUDE;
  return { x, y };
}

function astroFormatDegrees(rad){
  const deg = rad * 180 / Math.PI;
  return deg.toFixed(1).replace(".", ",") + "¬∞";
}

function astroBuildStaticSine(pathAboveEl, pathBelowEl){
  // Builds a *static* sinusoid that never changes with location.
  // Only the dot position changes based on rise/set times.
  if(!pathAboveEl || !pathBelowEl) return;

  const steps = 200;
  let aboveD = "";
  let belowD = "";

  for(let i=0;i<=steps;i++){
    const t = i/steps; // 0..1
    const x = ASTRO_MIN_X + t*(ASTRO_MAX_X - ASTRO_MIN_X);
    const y = ASTRO_BASELINE_Y - Math.sin(2*Math.PI*t) * ASTRO_AMPLITUDE;

    const isAbove = y <= ASTRO_BASELINE_Y + 1e-6; // numerical tolerance
    const cmd = (i===0 ? "M" : "L");

    if(isAbove){
      aboveD += ` ${cmd} ${x.toFixed(2)} ${y.toFixed(2)}`;
    }else{
      belowD += ` ${cmd} ${x.toFixed(2)} ${y.toFixed(2)}`;
    }
  }

  // Split into two continuous paths (above/below). We rebuild with separate M/L segments.
  function normalizePath(d, isAbove){
    const pts = d.trim().split(/\s+[ML]\s+/).filter(Boolean);
    // The split logic above can leave an initial point without command; rebuild robustly:
    const coords = [];
    for(const part of pts){
      const m = part.trim().match(/^(-?\d+(?:\.\d+)?)\s+(-?\d+(?:\.\d+)?)/);
      if(m) coords.push([m[1], m[2]]);
    }
    if(coords.length === 0) return "";
    let out = `M ${coords[0][0]} ${coords[0][1]}`;
    for(let j=1;j<coords.length;j++){
      out += ` L ${coords[j][0]} ${coords[j][1]}`;
    }
    return out;
  }

  // The simple builder above already separated points, but commands were mixed.
  // Rebuild by sampling again with segment starts on horizon crossings.
  aboveD = "";
  belowD = "";
  let lastAbove = null;
  for(let i=0;i<=steps;i++){
    const t = i/steps;
    const x = ASTRO_MIN_X + t*(ASTRO_MAX_X - ASTRO_MIN_X);
    const y = ASTRO_BASELINE_Y - Math.sin(2*Math.PI*t) * ASTRO_AMPLITUDE;
    const isAbove = y <= ASTRO_BASELINE_Y + 1e-6;

    if(isAbove){
      aboveD += (lastAbove === true ? " L " : " M ") + `${x.toFixed(2)} ${y.toFixed(2)}`;
    }else{
      belowD += (lastAbove === false ? " L " : " M ") + `${x.toFixed(2)} ${y.toFixed(2)}`;
    }
    lastAbove = isAbove;
  }

  pathAboveEl.setAttribute("d", aboveD.trim());
  pathBelowEl.setAttribute("d", belowD.trim());
}

// Compute last/next rise and the sunset in between (for dot mapping)
function astroGetCycleTimesSun(now, lat, lon){
  if(!window.SunCalc) return null;

  const oneDay = 24*60*60*1000;
  const d0 = new Date(now); d0.setHours(12,0,0,0); // midday avoids DST edge cases
  const dPrev = new Date(d0.getTime() - oneDay);
  const dNext = new Date(d0.getTime() + oneDay);

  const tPrev = SunCalc.getTimes(dPrev, lat, lon);
  const t0    = SunCalc.getTimes(d0,   lat, lon);
  const tNext = SunCalc.getTimes(dNext, lat, lon);

  const rises = [tPrev.sunrise, t0.sunrise, tNext.sunrise].filter(x => x instanceof Date && !isNaN(x));
  const sets  = [tPrev.sunset,  t0.sunset,  tNext.sunset ].filter(x => x instanceof Date && !isNaN(x));

  if(!rises.length || !sets.length) return null;

  // last rise before now, next rise after now
  const lastRise = rises.filter(r => r.getTime() <= now.getTime()).sort((a,b)=>b-a)[0];
  const nextRise = rises.filter(r => r.getTime() >  now.getTime()).sort((a,b)=>a-b)[0] || new Date(lastRise.getTime()+oneDay);

  // sunset between lastRise and nextRise
  const sunset = sets.filter(s => s.getTime() > lastRise.getTime() && s.getTime() < nextRise.getTime()).sort((a,b)=>a-b)[0] || null;

  return { lastRise, nextRise, sunset };
}

function astroGetCycleTimesMoon(now, lat, lon){
  if(!window.SunCalc) return null;

  const oneDay = 24*60*60*1000;
  const d0 = new Date(now); d0.setHours(12,0,0,0);
  const dPrev = new Date(d0.getTime() - oneDay);
  const dNext = new Date(d0.getTime() + oneDay);

  const pPrev = SunCalc.getMoonTimes(dPrev, lat, lon);
  const p0    = SunCalc.getMoonTimes(d0,   lat, lon);
  const pNext = SunCalc.getMoonTimes(dNext, lat, lon);

  // Handle polar cases
  if(p0.alwaysUp || p0.alwaysDown){
    return { alwaysUp: !!p0.alwaysUp, alwaysDown: !!p0.alwaysDown };
  }

  const rises = [pPrev.rise, p0.rise, pNext.rise].filter(x => x instanceof Date && !isNaN(x));
  const sets  = [pPrev.set,  p0.set,  pNext.set ].filter(x => x instanceof Date && !isNaN(x));

  if(!rises.length || !sets.length) return null;

  const lastRise = rises.filter(r => r.getTime() <= now.getTime()).sort((a,b)=>b-a)[0];
  const nextRise = rises.filter(r => r.getTime() >  now.getTime()).sort((a,b)=>a-b)[0] || new Date(lastRise.getTime()+oneDay);
  const moonset = sets.filter(s => s.getTime() > lastRise.getTime() && s.getTime() < nextRise.getTime()).sort((a,b)=>a-b)[0] || null;

  return { lastRise, nextRise, moonset };
}

function astroTFromCycle(now, cycle){
  // Maps "now" to a t in [0..1) on a static sine:
  // 0   = rise, 0.5 = set, 1 = next rise
  const oneDay = 24*60*60*1000;

  if(!cycle || cycle.alwaysUp || cycle.alwaysDown){
    // fallback: real clock time
    return astroDayFraction(now);
  }

  const lastRise = cycle.lastRise;
  const nextRise = cycle.nextRise || new Date(lastRise.getTime() + oneDay);
  const setTime = cycle.sunset || cycle.moonset;

  const span = Math.max(60*1000, nextRise.getTime() - lastRise.getTime()); // avoid divide-by-zero
  const raw = (now.getTime() - lastRise.getTime()) / span;
  const frac = Math.min(0.999999, Math.max(0, raw));

  if(setTime && setTime.getTime() > lastRise.getTime() && setTime.getTime() < nextRise.getTime()){
    const daySpan = Math.max(60*1000, setTime.getTime() - lastRise.getTime());
    const nightSpan = Math.max(60*1000, nextRise.getTime() - setTime.getTime());
    if(now.getTime() < setTime.getTime()){
      return (now.getTime() - lastRise.getTime()) / daySpan * 0.5;
    }
    return 0.5 + (now.getTime() - setTime.getTime()) / nightSpan * 0.5;
  }

  // if no set available, linear through the whole cycle
  return frac;
}

function astroPointOnStaticSine(t){
  const x = ASTRO_MIN_X + t * (ASTRO_MAX_X - ASTRO_MIN_X);
  const y = ASTRO_BASELINE_Y - Math.sin(2*Math.PI*t) * ASTRO_AMPLITUDE;
  return { x, y };
}

function updateAstroWidget(){
  if(!window.SunCalc || !sunDotEl || !moonDotEl) return;

  const now = new Date();
  const { lat, lon } = astroState;

  // Build static curves once (never change with location)
  if(!window.__astroStaticBuilt){
    astroBuildStaticSine(sunPathAboveEl, sunPathBelowEl);
    astroBuildStaticSine(moonPathAboveEl, moonPathBelowEl);
    window.__astroStaticBuilt = true;
  }

  // SUN: map dot along static sine using sunrise/sunset cycle
  const sunCycle = astroGetCycleTimesSun(now, lat, lon);
  const tSun = astroTFromCycle(now, sunCycle);
  const sunPt = astroPointOnStaticSine(tSun);
  sunDotEl.setAttribute("cx", sunPt.x);
  sunDotEl.setAttribute("cy", sunPt.y);
  const sunPos = SunCalc.getPosition(now, lat, lon);
  if(sunAltLabel){
    sunAltLabel.textContent = "V√Ω≈°ka: " + astroFormatDegrees(sunPos.altitude);
  }

  // MOON: same mapping via moonrise/moonset cycle (fallback for polar cases)
  const moonCycle = astroGetCycleTimesMoon(now, lat, lon);
  const tMoon = astroTFromCycle(now, moonCycle);
  const moonPt = astroPointOnStaticSine(tMoon);
  moonDotEl.setAttribute("cx", moonPt.x);
  moonDotEl.setAttribute("cy", moonPt.y);
  const moonPos = SunCalc.getMoonPosition(now, lat, lon);
  if(moonAltLabel){
    moonAltLabel.textContent = "V√Ω≈°ka: " + astroFormatDegrees(moonPos.altitude);
  }
}

function updateAstroLocation(lat, lon){
  astroState.lat = lat;
  astroState.lon = lon;
  updateAstroWidget();
}

// prvn√≠ vykreslen√≠ + pravideln√° aktualizace
updateAstroWidget();
setInterval(updateAstroWidget, 60*1000);


async function fetchMoonPhase(lat,lon){
  // napojen√≠ astro widgetu na stejn√© sou≈ôadnice
  updateAstroLocation(lat, lon);
  try{ if(window.__selectedNightDate){ updateNightInfo(window.__selectedNightDate); } }catch(e){}

  const url=`https://api.ipgeolocation.io/astronomy?apiKey=${IPGEO_API_KEY}&lat=${lat}&long=${lon}`;
  try{
    const r=await fetch(url);
    const d=await r.json();

    // Moon Phase
    const p=d.moon_phase||"Nezn√°m√° f√°ze";
    $("moon-phase-label").textContent=getMoonEmojiFromName(p);
    // Moon illumination (%) - field name differs across API versions:
    // - moon_illumination_percentage (docs) or moon_illumination (older)
    const illumRaw =
      (d.moon_illumination_percentage ?? d.moon_illumination ??
       (d.astronomy && (d.astronomy.moon_illumination_percentage ?? d.astronomy.moon_illumination)));

    // Normalize to number (0..100)
    let illumPct = null;
    if(illumRaw != null && illumRaw !== ""){
      const s = String(illumRaw).trim().replace("%","");
      const n = Number(s);
      if(!Number.isNaN(n)) illumPct = n;
    }

    const illumStr = (illumPct != null) ? (Math.round(illumPct) + "%") : "‚Äî";
    const illumEl = document.getElementById("moon-illum-label");
    if(illumEl) illumEl.textContent = illumStr;


    // Sun Times (Sunrise/Sunset)
    const sunRise = d.sunrise ? d.sunrise.substring(0, 5) : '‚Äî';
    const sunSet = d.sunset ? d.sunset.substring(0, 5) : '‚Äî';
    $("sun-rise-label").textContent = sunRise;
    $("sun-set-label").textContent = sunSet;

    // Moon Times (Moonrise/Moonset)
    const moonRise = (d.moonrise && d.moonrise !== '00:00') ? d.moonrise.substring(0, 5) : 'N/A';
    const moonSet = (d.moonset && d.moonset !== '00:00') ? d.moonset.substring(0, 5) : 'N/A';
    $("moon-rise-label").textContent = moonRise;
    $("moon-set-label").textContent = moonSet;

    const today = new Date().toLocaleDateString('en-CA', { timeZone: 'Europe/Prague' });
// Store illumination for 'today' so the widget can draw correctly (0..1)
moonIllumByDate[today] = (illumPct != null) ? Math.max(0, Math.min(1, illumPct / 100)) : 0;

}catch(e){
    console.error("Chyba p≈ôi naƒç√≠t√°n√≠ f√°ze/slunce/mƒõs√≠ce:",e);
    $("moon-phase-label").textContent="Chyba naƒç√≠t√°n√≠";
    const illumEl = document.getElementById("moon-illum-label");
    if(illumEl) illumEl.textContent = "‚Äî";
    $("sun-rise-label").textContent = "‚Äî";
    $("sun-set-label").textContent = "‚Äî";
    $("moon-rise-label").textContent = "‚Äî";
    $("moon-set-label").textContent = "‚Äî";
  }
}

/* ===== Star visibility score (pro seeing re≈æim) ===== */
function visibilityScore(cloud, precip, dateStr){
  const cloudScore = 100 - Math.min(Math.max(cloud,0),100);
  const rainPenalty = Math.min(precip*50, 50);
  const illum = moonIllumByDate[dateStr] ?? 0;  // 0..1
  const moonPenalty = illum * 40;
  const raw = cloudScore - rainPenalty - moonPenalty;
  return Math.max(0, Math.min(100, Math.round(raw)));
}

/* Compute exact width of cards */
function measureCardsWidth(scrollEl){
  const cards = scrollEl.querySelectorAll('.forecast-card');
  if(cards.length === 0) return 0;
  const style = getComputedStyle(scrollEl);
  const gap = parseFloat(style.columnGap || style.gap || 0) || 0;
  let sum = 0;
  cards.forEach((c)=>{ sum += c.getBoundingClientRect().width; });
  sum += gap * (cards.length - 1);
  return Math.ceil(sum);
}

/* ===== Scaling ===== */
const RAIN_MAX_MM = 5;     // 0..5 mm/h => 100 %
const WIND_MAX_KMH = 50;   // 0..50 km/h => 100 %
const TEMP_MAX_C = 35;     // pro fallback normalizaci (pokud by chybƒõl rozsah dne)

/* ===== Mode score (0..100) ===== */
function scoreForMode(entry, mode, dateStr){
  if(mode === 'seeing'){ // d≈ô√≠ve 'cloud'
    return Math.max(0, Math.min(100, 100 - (entry.cloud ?? 0)));
  }
  if(mode === 'wind'){
    const w = Math.max(0, Math.min(WIND_MAX_KMH, entry.wind ?? 0));
    return Math.round(100 * (w / WIND_MAX_KMH)); // 0..100 (v√≠c vƒõtru = v√Ω≈°)
  }
  if(mode === 'rain'){
    const r = Math.max(0, Math.min(RAIN_MAX_MM, entry.rain ?? 0));
    return Math.round(100 * (r / RAIN_MAX_MM)); // 0..100 (v√≠c sr√°≈æek = v√Ω≈°)
  }
  // fallback: seeing
  return visibilityScore(entry.cloud ?? 0, entry.rain ?? 0, dateStr);
}

/* ===== Graph drawing ===== */
function clamp01(x){ return Math.max(0, Math.min(1, x)); }
function hexToRgb(hex){
  const h = String(hex || '').trim().replace('#','');
  if(h.length === 3){
    return {
      r: parseInt(h[0]+h[0], 16),
      g: parseInt(h[1]+h[1], 16),
      b: parseInt(h[2]+h[2], 16)
    };
  }
  if(h.length === 6){
    return {
      r: parseInt(h.slice(0,2), 16),
      g: parseInt(h.slice(2,4), 16),
      b: parseInt(h.slice(4,6), 16)
    };
  }
  return {r:255,g:255,b:255};
}
function mixRgb(a,b,t){
  const tt = clamp01(t);
  return {
    r: Math.round(a.r + (b.r - a.r) * tt),
    g: Math.round(a.g + (b.g - a.g) * tt),
    b: Math.round(a.b + (b.b - a.b) * tt)
  };
}
function rgbaStr(rgb, a){
  return `rgba(${rgb.r},${rgb.g},${rgb.b},${a})`;
}
function tempColor(tempC, rangeAbs){
  // rangeAbs = max(abs(min), abs(max)) pro dan√Ω den; 0 => fallback
  const range = Math.max(0.5, Number(rangeAbs) || 0);
  if(tempC <= 0){
    // svƒõtle modr√° -> hlubok√° modr√°
    const coldT = clamp01(Math.abs(tempC) / range);
    const light = hexToRgb('#7dd3fc');
    const deep  = hexToRgb('#1d4ed8');
    return mixRgb(light, deep, coldT);
  }
  // ≈ælut√° -> oran≈æov√° -> ƒçerven√°
  const hotT = clamp01(tempC / range);
  const yellow = hexToRgb('#facc15');
  const orange = hexToRgb('#fb923c');
  const red    = hexToRgb('#ef4444');
  if(hotT < 0.5) return mixRgb(yellow, orange, hotT * 2);
  return mixRgb(orange, red, (hotT - 0.5) * 2);
}

function drawBackgroundGraph(scrollEl, entries, dateStr, mode='seeing'){
  const old = scrollEl.querySelector('.bg-graph');
  if(old) old.remove();

  let totalW = measureCardsWidth(scrollEl);
  if(!Number.isFinite(totalW) || totalW <= 0) totalW = Math.max(1, scrollEl.scrollWidth);

  const totalH = scrollEl.getBoundingClientRect().height || 140;

  const svgNS="http://www.w3.org/2000/svg";
  const wrap = document.createElement('div');
  wrap.className = "bg-graph";
  wrap.style.width = totalW + "px";
  wrap.style.height = totalH + "px";

  const svg = document.createElementNS(svgNS, 'svg');
  svg.setAttribute('width', totalW);
  svg.setAttribute('height', totalH);
  svg.style.display='block';

  const defs = document.createElementNS(svgNS,'defs');
  const mkGrad = (id, lowVar, highVar) => {
    const lg = document.createElementNS(svgNS,'linearGradient');
    lg.setAttribute('id', id);
    lg.setAttribute('x1','0'); lg.setAttribute('y1','1');
    lg.setAttribute('x2','0'); lg.setAttribute('y2','0');
    const stop1 = document.createElementNS(svgNS,'stop');
    stop1.setAttribute('offset','0%');  stop1.setAttribute('stop-color', getComputedStyle(document.documentElement).getPropertyValue(lowVar).trim() || 'white');
    const stop2 = document.createElementNS(svgNS,'stop');
    stop2.setAttribute('offset','100%');stop2.setAttribute('stop-color', getComputedStyle(document.documentElement).getPropertyValue(highVar).trim() || 'black');
    lg.appendChild(stop1); lg.appendChild(stop2);
    return lg;
  };
  defs.appendChild(mkGrad('rainGrad','--rainLow','--rainHigh'));
  defs.appendChild(mkGrad('windGrad','--windLow','--windHigh'));
  defs.appendChild(mkGrad('tempGrad','--tempLow','--tempHigh'));
  svg.appendChild(defs);

  if(mode === 'seeing'){
    const midY = totalH/2;
    const amp = (totalH/2) * 0.9;

    const baseline = document.createElementNS(svgNS, 'line');
    baseline.setAttribute('x1', 0); baseline.setAttribute('y1', midY);
    baseline.setAttribute('x2', totalW); baseline.setAttribute('y2', midY);
    baseline.setAttribute('stroke', 'rgba(255,255,255,0.2)');
    baseline.setAttribute('stroke-width', '1');
    svg.appendChild(baseline);

    const n = entries.length;
    if(n<2){ wrap.appendChild(svg); scrollEl.insertAdjacentElement('afterbegin', wrap); return; }

    const points = [];
    for(let i=0;i<n;i++){
      const x = (totalW-1) * (i/(n-1));
      const score = scoreForMode(entries[i], 'seeing', dateStr);
      const norm = score - 50; // -50..+50
      const y = midY - (norm/50)*amp;
      points.push([x,y]);
    }

    const makeAreaPath = (clampFn, fill) => {
      const dTop = points.map(([x,y],i)=> (i===0 ? `M ${x} ${clampFn(y)}` : `L ${x} ${clampFn(y)}`)).join(' ');
      const d = `${dTop} L ${points[n-1][0]} ${midY} L ${points[0][0]} ${midY} Z`
      const p = document.createElementNS(svgNS, 'path');
      p.setAttribute('d', d);
      p.setAttribute('fill', fill);
      p.setAttribute('stroke', 'transparent');
      return p;
    };
    svg.appendChild(makeAreaPath(y => Math.min(y, midY), 'var(--greenFill)'));
    svg.appendChild(makeAreaPath(y => Math.max(y, midY), 'var(--redFill)'));

    const linePath = document.createElementNS(svgNS, 'path');
    const dLine = points.map(([x,y],i)=> (i===0 ? `M ${x} ${y}` : `L ${x} ${y}`)).join(' ');
    linePath.setAttribute('d', dLine);
    linePath.setAttribute('fill', 'none');
    linePath.setAttribute('stroke', 'rgba(255,255,255,0.6)');
    linePath.setAttribute('stroke-width', '1.6');
    svg.appendChild(linePath);
  } else if(mode === 'temp') {
    // Teplota: 0 ¬∞C je uprost≈ôed (symetrick√© ≈°k√°lov√°n√≠) + barvy podle znam√©nka a velikosti
    const midY = totalH/2;
    const amp = (totalH/2) * 0.9;

    const zeroLine = document.createElementNS(svgNS, 'line');
    zeroLine.setAttribute('x1', 0); zeroLine.setAttribute('y1', midY);
    zeroLine.setAttribute('x2', totalW); zeroLine.setAttribute('y2', midY);
    zeroLine.setAttribute('stroke', 'rgba(255,255,255,0.22)');
    zeroLine.setAttribute('stroke-width', '1');
    svg.appendChild(zeroLine);

    const n = entries.length;
    if(n<2){ wrap.appendChild(svg); scrollEl.insertAdjacentElement('afterbegin', wrap); return; }

    // Najdi min/max a udƒõlej symetrick√Ω rozsah kolem nuly
    let tMin = Infinity, tMax = -Infinity;
    for(const e of entries){
      const t = Number(e.temp);
      if(Number.isFinite(t)){
        if(t < tMin) tMin = t;
        if(t > tMax) tMax = t;
      }
    }
    let rangeAbs = Math.max(Math.abs(tMin), Math.abs(tMax));
    if(!Number.isFinite(rangeAbs) || rangeAbs < 0.5) rangeAbs = TEMP_MAX_C;

    const pts = [];
    for(let i=0;i<n;i++){
      const x = (totalW-1) * (i/(n-1));
      const t = Number(entries[i].temp);
      const tt = Number.isFinite(t) ? t : 0;
      const y = midY - (tt / rangeAbs) * amp;
      pts.push({x,y,t:tt});
    }

    // V√Ωpl≈à po segmentech (trapezoidy k nulov√© linii) + barva dle pr≈Ømƒõru segmentu
    for(let i=0;i<n-1;i++){
      const a = pts[i], b = pts[i+1];
      const tAvg = (a.t + b.t) / 2;
      const col = tempColor(tAvg, rangeAbs);
      const p = document.createElementNS(svgNS,'path');
      const d = `M ${a.x} ${midY} L ${a.x} ${a.y} L ${b.x} ${b.y} L ${b.x} ${midY} Z`;
      p.setAttribute('d', d);
      p.setAttribute('fill', rgbaStr(col, 0.22));
      p.setAttribute('stroke', 'none');
      svg.appendChild(p);
    }

    // ƒå√°ra po segmentech, aby mohla mƒõnit barvu
    for(let i=0;i<n-1;i++){
      const a = pts[i], b = pts[i+1];
      const tAvg = (a.t + b.t) / 2;
      const col = tempColor(tAvg, rangeAbs);
      const seg = document.createElementNS(svgNS,'path');
      seg.setAttribute('d', `M ${a.x} ${a.y} L ${b.x} ${b.y}`);
      seg.setAttribute('fill','none');
      seg.setAttribute('stroke', rgbaStr(col, 0.95));
      seg.setAttribute('stroke-width','1.9');
      seg.setAttribute('stroke-linecap','round');
      seg.setAttribute('stroke-linejoin','round');
      svg.appendChild(seg);
    }
  } else {
    // V√≠tr / D√©≈°≈•: klasick√° plocha 0..100 % (dole -> naho≈ôe)
    const baseY = totalH - 2;
    const topPad = 6;
    const usableH = Math.max(20, baseY - topPad);

    const baseLine = document.createElementNS(svgNS,'line');
    baseLine.setAttribute('x1',0); baseLine.setAttribute('y1',baseY);
    baseLine.setAttribute('x2',totalW); baseLine.setAttribute('y2',baseY);
    baseLine.setAttribute('stroke','rgba(255,255,255,.18)');
    svg.appendChild(baseLine);

    const n = entries.length;
    if(n<2){ wrap.appendChild(svg); scrollEl.insertAdjacentElement('afterbegin', wrap); return; }

    const points=[];
    for(let i=0;i<n;i++){
      const x=(totalW-1)*(i/(n-1));
      const score = scoreForMode(entries[i], mode, dateStr);
      const y= baseY - (score/100)*usableH;
      points.push([x,y]);
    }

    const dTop = points.map(([x,y],i)=> (i?`L ${x} ${y}`:`M ${x} ${y}`)).join(' ');
    const dArea = `${dTop} L ${points[n-1][0]} ${baseY} L ${points[0][0]} ${baseY} Z`;
    const area = document.createElementNS(svgNS,'path');
    area.setAttribute('d', dArea);
    area.setAttribute('fill', mode==='rain' ? 'url(#rainGrad)' : 'url(#windGrad)');
    area.setAttribute('stroke','none');
    svg.appendChild(area);

    const line=document.createElementNS(svgNS,'path');
    const dLine = points.map(([x,y],i)=> (i?`L ${x} ${y}`:`M ${x} ${y}`)).join(' ');
    line.setAttribute('d', dLine);
    line.setAttribute('fill','none');
    line.setAttribute('stroke', mode==='rain'
      ? (getComputedStyle(document.documentElement).getPropertyValue('--rainHigh').trim() || '#1e3a8a')
      : (getComputedStyle(document.documentElement).getPropertyValue('--windHigh').trim() || '#03543f')
    );
    line.setAttribute('stroke-width','1.8');
    svg.appendChild(line);
  }

  wrap.appendChild(svg);
  scrollEl.insertBefore(wrap, scrollEl.firstChild);
}

/* ===== Forecast ===== */
window._graphData = {};
window._graphMode = {};

function updateNowStatusFromArrays(timeArr, tempArr, cloudArr, rainArr, windArr){
  if(!(timeArr && timeArr.length)) return;
  try{
    const nowDate = new Date();
    const tz = 'Europe/Prague';
    const y = nowDate.toLocaleString('en-CA', { timeZone: tz, year:'numeric' });
    const m = nowDate.toLocaleString('en-CA', { timeZone: tz, month:'2-digit' });
    const d = nowDate.toLocaleString('en-CA', { timeZone: tz, day:'2-digit' });
    const hh = nowDate.toLocaleString('en-GB', { timeZone: tz, hour:'2-digit', hour12:false });
    const target = `${y}-${m}-${d}T${hh}:00`;
    let idx = timeArr.indexOf(target);
    if(idx < 0){ // pick next closest hour in future, else last
      idx = timeArr.findIndex(t => t >= target);
      if(idx < 0) idx = timeArr.length - 1;
    }
    const [dateStr] = timeArr[idx].split('T');
    const temp = Math.round(tempArr[idx]);
    const cloud = cloudArr[idx];
    const rain = rainArr[idx];
    const wind = Math.round(windArr[idx]);
    const seeing = visibilityScore(cloud, rain, dateStr);
    $("nowTemp").textContent = `${temp}¬∞C`;
    $("nowWind").textContent = `${wind} km/h`;
    $("nowRain").textContent = `${rain} mm/h`;
    $("nowSeeing").textContent = `${seeing}/100`;
    $("nowStatus").style.display = "flex";
  }catch(e){ console.warn("NOW status update failed", e); }
}

async function fetchForecast(lat,lon){
  showSpinner(true);
  const r=await fetch(`https://api.open-meteo.com/v1/forecast?latitude=${lat}&longitude=${lon}&hourly=temperature_2m,cloudcover,precipitation,windspeed_10m&timezone=auto`);
  const d=await r.json();
  // Update local time for selected location (using Open-Meteo timezone info)
  // IMPORTANT: don't manually add utc_offset_seconds and then format in local timezone,
  // that causes a +1h (or other) double-offset. Always format using Intl timeZone.
  try {
    const tzName = d.timezone || "";
    const offsetSeconds = typeof d.utc_offset_seconds === "number" ? d.utc_offset_seconds : 0;
    window.__lastUtcOffsetSeconds = offsetSeconds;
    window.__lastTzName = tzName;

    const ltEl = document.getElementById("info-localtime");
    if (ltEl) {
      if (tzName) {
        const timeStr = new Date().toLocaleTimeString("cs-CZ", { hour: "2-digit", minute: "2-digit", timeZone: tzName });
        ltEl.textContent = `${timeStr} (${tzName})`;
      } else {
        // Fallback: format UTC+offset explicitly (avoid browser local TZ)
        const utcMs = Date.now();
        const shifted = new Date(utcMs + offsetSeconds * 1000);
        const timeStr = shifted.toLocaleTimeString("cs-CZ", { hour: "2-digit", minute: "2-digit", timeZone: "UTC" });
        ltEl.textContent = timeStr;
      }
    }
  } catch (e) {
    const ltEl = document.getElementById("info-localtime");
    if (ltEl) ltEl.textContent = "‚Äî";
  }

  showSpinner(false);
  const {time,temperature_2m,cloudcover,precipitation,windspeed_10m}=d.hourly;

  // Update topbar NOW status
  updateNowStatusFromArrays(time, temperature_2m, cloudcover, precipitation, windspeed_10m);

  const div=$("forecast");div.innerHTML="";
  const days={};
  
  for(let i=0;i<time.length;i++){
    let [date,hour] = time[i].split('T');
    if(hour === '24:00'){
      const dt = new Date(date + 'T00:00:00');
      const next = new Date(dt.getTime() + 24*60*60*1000);
      const y = next.getFullYear();
      const m = String(next.getMonth()+1).padStart(2,'0');
      const d2 = String(next.getDate()).padStart(2,'0');
      date = `${y}-${m}-${d2}`;
      hour = '00:00';
    }
    const entry={time:hour,temp:temperature_2m[i],cloud:cloudcover[i],rain:precipitation[i],wind:windspeed_10m[i],date};
    if(!days[date]) days[date]=[];
    if(time[i].startsWith(date+'T')){
      days[date].push(entry);
    }
  }

  let idx=0;
  Object.entries(days).sort((a,b)=> a[0]<b[0]? -1 : a[0]>b[0]? 1 : 0).forEach(([date,entries])=>{
    if(!entries.length) return;
    try{
      const todayLocal = new Date().toLocaleDateString('en-CA', { timeZone: 'Europe/Prague' });
      if(date === todayLocal){
        const nowHHmm = new Date().toLocaleTimeString('en-GB', { hour: '2-digit', minute: '2-digit', hour12: false, timeZone: 'Europe/Prague' });
        entries = entries.filter(e => e.time >= nowHHmm);
      }
    }catch(e){/* noop */}

    const section=document.createElement('div'); section.className='forecast-day';
    const header=document.createElement('h3'); const contentId=`day-${idx++}`;
    header.dataset.date=date;
    header.style.cursor = 'pointer';
    header.title = 'Klikni: zobrazit astronomickou noc pro tento den';
    header.addEventListener('click', ()=>{
      window.__selectedNightDate = date;
      updateNightInfo(date);
    });


    const leftPart = document.createElement('div');
    leftPart.style.display='flex';
    leftPart.style.alignItems='center';
    leftPart.style.gap='10px';
    leftPart.style.flexWrap='wrap';
    leftPart.innerHTML = `
      <span class="day-title">${getDayName(date)}</span>
      <span class="day-sub">${date}</span>
      <span class="day-actions">
        <button class="mini-btn" onclick="event.stopPropagation(); goToStart('${contentId}')">R√°no</button>
        <button class="mini-btn" onclick="event.stopPropagation(); centerTime('${contentId}', '12:00')">Poledne</button>
        <button class="mini-btn" onclick="event.stopPropagation(); centerTime('${contentId}', '23:00')">P≈Ølnoc</button>
      </span>`;

    const tabs = document.createElement('div');
    tabs.className='mode-tabs';
    tabs.innerHTML = `
      <button class="mode-btn active" data-mode="seeing" title="Seeing (lep≈°√≠ ‚Üë)">üëÅÔ∏è</button>
      <button class="mode-btn" data-mode="wind" title="V√≠tr (svƒõtl√° ‚Üì ‚Üí tmav√° ‚Üë)">üí®</button>
      <button class="mode-btn" data-mode="rain" title="D√©≈°≈• (svƒõtl√° ‚Üì ‚Üí tmav√° ‚Üë)">üåßÔ∏è</button>
      <button class="mode-btn" data-mode="temp" title="Teplota">üå°Ô∏è</button>`;
    tabs.addEventListener('click', (e)=>{
      if(!(e.target instanceof HTMLElement)) return;
      const btn = e.target.closest('.mode-btn'); if(!btn) return;
      e.stopPropagation();
      const mode = btn.getAttribute('data-mode');
      changeGraphMode(contentId, mode);
      tabs.querySelectorAll('.mode-btn').forEach(b=>b.classList.remove('active'));
      btn.classList.add('active');
    });

    header.appendChild(leftPart);
/* tabs removed */
/* collapse disabled */
section.appendChild(header);

    const content=document.createElement('div'); content.className='forecast-content'; content.id=contentId; content.style.display='block';
    const wrapper=document.createElement('div'); wrapper.className='forecast-scroll-wrapper';
    const leftBtn=document.createElement('button'); leftBtn.className='scroll-left'; leftBtn.textContent='‚óÄ';
    const rightBtn=document.createElement('button'); rightBtn.className='scroll-right'; rightBtn.textContent='‚ñ∂';
    const scroll=document.createElement('div'); scroll.className='forecast-scroll';
    leftBtn.onclick=()=>scroll.scrollBy({left:-250,behavior:'smooth'});
    rightBtn.onclick=()=>scroll.scrollBy({left:250,behavior:'smooth'});
    wrapper.appendChild(leftBtn); wrapper.appendChild(scroll); wrapper.appendChild(rightBtn);

    entries.forEach(e => {
      const card=document.createElement('div'); card.className='forecast-card';
      const icon=getWeatherIcon(e.cloud, e.rain);
      card.innerHTML=`<div><strong>${e.time}</strong></div>
                      <div style="font-size:1.4em">${icon}</div>
                      <div>${Math.round(e.temp)}¬∞C</div>
                      <div>‚òÅÔ∏è ${Math.round(e.cloud)}%</div>
                      <div>üåßÔ∏è ${e.rain} mm</div>
                      <div>üí® ${Math.round(e.wind)} km/h</div>`;
      scroll.appendChild(card);
    });

    content.appendChild(wrapper);
    section.appendChild(content);
    div.appendChild(section);

    window._graphData[contentId] = { entries, date };
    window._graphMode[contentId] = 'seeing';
    requestAnimationFrame(()=> drawBackgroundGraph(scroll, entries, date, 'seeing'));
  });

  // === Astronomick√° noc: zvol v√Ωchoz√≠ den a vykresli indik√°tory ===
  try{
    const dates = Object.keys(days).sort();
    if(dates.length){
      const todayLocal = new Date().toLocaleDateString('en-CA', { timeZone: window.__lastTzName || 'Europe/Prague' });
      window.__selectedNightDate = (dates.includes(todayLocal) ? todayLocal : dates[0]);
      updateNightInfo(window.__selectedNightDate);
    }
  }catch(e){}

  syncMapHeight();
}

/* ===== Toggle & focus helpers ===== */
function toggleForecast(id){const c=document.getElementById(id);const i=$(id+'-icon');if(c.style.display==='none'){c.style.display='block';i.textContent='‚¨ÜÔ∏è'}else{c.style.display='none';i.textContent='‚¨áÔ∏è'}}
function goToStart(contentId){const sc=document.querySelector(`#${contentId} .forecast-scroll`);if(!sc)return;sc.scrollTo({left:0,behavior:'smooth'});}
function centerTime(contentId,target){
  const sc=document.querySelector(`#${contentId} .forecast-scroll`); if(!sc) return;
  const cards=sc.querySelectorAll('.forecast-card');
  let found=false;
  for(let i=0;i<cards.length;i++){
    const strong=cards[i].querySelector('strong');
    if(strong&&strong.textContent.trim()===target){
      const w=sc.clientWidth;const off=cards[i].offsetLeft;const cw=cards[i].offsetWidth;
      sc.scrollTo({left:off-(w/2)+(cw/2),behavior:'smooth'});
      found=true;break;
    }
  }
  if(!found){ // pokud konkr√©tn√≠ hodina chyb√≠ (t≈ôeba u dne≈°ka), vra≈• na zaƒç√°tek
    goToStart(contentId);
  }
}

/* Change graph mode for a given day */
function changeGraphMode(contentId, mode){
  window._graphMode[contentId] = mode;
  const sc = document.querySelector(`#${contentId} .forecast-scroll`);
  const data = window._graphData[contentId];
  if(sc && data){
    drawBackgroundGraph(sc, data.entries, data.date, mode);
  }
}

/* ===== Layout sync ===== */
window.addEventListener('load', syncMapHeight);

/* ===== RainViewer overlays: radar + IR clouds (MODIFIED) ===== */
let rvState = {
  host: 'https://tilecache.rainviewer.com',
  radarPath: null,
  satPath: null,
  radarLayer: null,
  satLayer: null,
  control: null,
  lastTsRadar: 0,
  lastTsSat: 0
};

async function loadRainviewerMeta(){
  try{
    const res = await fetch('https://api.rainviewer.com/public/weather-maps.json', { cache: 'no-store' });
    const data = await res.json();
    rvState.host = data.host || rvState.host;

    // latest radar: prefer nowcast if available, else last past
    let radarFrames = (data.radar?.nowcast && data.radar.nowcast.length ? data.radar.nowcast : data.radar?.past) || [];
    if(radarFrames.length){
      const last = radarFrames[radarFrames.length - 1];
      rvState.radarPath = last.path;
      rvState.lastTsRadar = last.time;
    }

    // latest satellite IR (clouds)
    const satFrames = (data.satellite?.infrared) || [];
    if(satFrames.length){
      const last = satFrames[satFrames.length - 1];
      rvState.satPath = last.path;
      rvState.lastTsSat = last.time;
    }
  }catch(e){
    console.warn('RainViewer meta fetch failed', e);
  }
}

function ensureRvLayers(){
  if(!map) return;
  // create/update radar layer
  if(rvState.radarPath){
    const url = `${rvState.host}${rvState.radarPath}/256/{z}/{x}/{y}/2/1_1.png`;
    if(rvState.radarLayer){
      rvState.radarLayer.setUrl(url);
    } else {
      rvState.radarLayer = L.tileLayer(url, { opacity: 0.65, zIndex: 450, attribution: 'Radar ¬© RainViewer' });
    }
  }
  // create/update satellite IR layer (clouds)
  if(rvState.satPath){
    const urlSat = `${rvState.host}${rvState.satPath}/256/{z}/{x}/{y}/0/0_0.png`; // satellite requires color=0 and options 0_0
    if(rvState.satLayer){
      rvState.satLayer.setUrl(urlSat);
    } else {
      rvState.satLayer = L.tileLayer(urlSat, { opacity: 0.5, zIndex: 440, attribution: 'Satellite ¬© RainViewer' });
    }
  }

  // M√≠sto toho se vol√° nov√° funkce, kter√° kombinuje z√°kladn√≠ mapy a p≈ôekryvy
  addLayerControl();
}

async function refreshWeatherLayers(){
  const prevRadar = rvState.lastTsRadar;
  const prevSat = rvState.lastTsSat;
  await loadRainviewerMeta();
  if(rvState.lastTsRadar && rvState.lastTsRadar !== prevRadar){
    ensureRvLayers();
  }
  if(rvState.lastTsSat && rvState.lastTsSat !== prevSat){
    ensureRvLayers();
  }
}

async function enableWeatherLayers(){
  await loadRainviewerMeta();
  ensureRvLayers();
}

// refresh every 10 minutes
setInterval(()=>{
  refreshWeatherLayers();
}, 10*60*1000);



/* ===== Diagnostics (minimal) ===== */
const diagList = document.getElementById('diagList');
function el(tag, attrs={}, html=""){
  const e=document.createElement(tag);
  for(const [k,v] of Object.entries(attrs)) e.setAttribute(k,v);
  if(html) e.innerHTML=html;
  return e;
}
function statusRow(name, statusClass, text){
  const row = el('div', {class:'diag-item'});
  row.appendChild(el('div',{class:'diag-name'}, name));
  row.appendChild(el('div',{class:'diag-status '+statusClass}, text));
  return row;
}
async function ping(url, timeout=4500){
  const controller = new AbortController();
  const id = setTimeout(()=>controller.abort(), timeout);
  try{
    const r = await fetch(url, {signal: controller.signal, method:'GET'});
    clearTimeout(id);
    return {ok:r.ok, status:r.status};
  }catch(e){
    clearTimeout(id);
    return {ok:false, status:'‚Äî', error: e && (e.name||e.message) ? (e.name||e.message) : 'error'};
  }
}
// Ping an image/tile URL (useful for map tile servers). Does not require CORS.
function imagePing(url, timeout=4500){
  return new Promise((resolve)=>{
    const img = new Image();
    let done = false;
    const t = setTimeout(()=>{
      if(done) return;
      done = true;
      try{ img.src = ""; }catch(_){}
      resolve({ok:false, status:'timeout'});
    }, timeout);

    img.onload = ()=>{
      if(done) return;
      done = true;
      clearTimeout(t);
      resolve({ok:true, status:'OK'});
    };
    img.onerror = ()=>{
      if(done) return;
      done = true;
      clearTimeout(t);
      resolve({ok:false, status:'error'});
    };
    // Prevent cached false positives; keep it lightweight
    const sep = url.includes('?') ? '&' : '?';
    img.src = url + sep + 't=' + Date.now();
  });
}
async function runDiagnostics(){
  if(!diagList) return;
  diagList.innerHTML = "";

  // Quick, lightweight checks. Some endpoints are "on-demand" in normal usage,
  // but we still ping them here using a safe sample query/coords.
  const endpoints = [
    // Open-Meteo
    { name: "Open-Meteo Forecast", type:"fetch", url: "https://api.open-meteo.com/v1/forecast?latitude=50.08&longitude=14.44&hourly=temperature_2m&timezone=Europe%2FPrague" },
    { name: "Open-Meteo Geocoding", type:"fetch", url: "https://geocoding-api.open-meteo.com/v1/search?name=Prague&count=1&language=cs&format=json" },

    // Astronomy
    { name: "ipgeolocation Astronomy", type:"fetch", url: `https://api.ipgeolocation.io/astronomy?apiKey=${IPGEO_API_KEY}&lat=50.08&long=14.44` },

    // Reverse geocoding
    { name: "Nominatim Reverse", type:"fetch", url: "https://nominatim.openstreetmap.org/reverse?format=json&lat=50.08&lon=14.44&zoom=10&addressdetails=1" },

    // Planets
    { name: "VisiblePlanets.dev", type:"fetch", url: "https://api.visibleplanets.dev/v3?latitude=50.08&longitude=14.44&aboveHorizon=true" },

    // RainViewer meta (radar/sat layers)
    { name: "RainViewer Meta", type:"fetch", url: "https://api.rainviewer.com/public/weather-maps.json" },

    // Map tile sources (image ping)
    { name: "OSM Tiles (Leaflet)", type:"image", url: "https://a.tile.openstreetmap.org/0/0/0.png" },
    { name: "Esri World Imagery Tiles", type:"image", url: "https://server.arcgisonline.com/ArcGIS/rest/services/World_Imagery/MapServer/tile/0/0/0" }
  ];

  for(const ep of endpoints){
    const row = statusRow(ep.name, 'pending', 'ƒçek√°m‚Ä¶');
    diagList.appendChild(row);
    const s = row.querySelector('.diag-status');

    try{
      let res;
      if(ep.type === "image"){
        res = await imagePing(ep.url);
        if(res.ok){ s.className='diag-status ok'; s.textContent='OK'; }
        else { s.className='diag-status fail'; s.textContent = (res.status === 'timeout') ? 'Timeout' : 'Chyba'; }
      }else{
        res = await ping(ep.url);
        if(res.ok){ s.className='diag-status ok'; s.textContent='OK '+res.status; }
        else { s.className='diag-status fail'; s.textContent = (res.status && res.status !== '‚Äî') ? ('Chyba '+res.status) : 'Chyba'; }
      }
    }catch(_e){
      s.className='diag-status fail';
      s.textContent='Chyba';
    }
  }

  // Informational items (not strict HTTP tests)
  const infoItems = [
    { name: "Leaflet (mapov√° knihovna)", text: (window.L ? "Naƒçteno" : "Nenaƒçteno") },
  ];
  for(const it of infoItems){
    const row = statusRow(it.name, 'info', it.text);
    diagList.appendChild(row);
  }
}
function openDiagModal(){
  const overlay = document.getElementById('diagOverlay');
  if(overlay){ overlay.style.display='flex'; runDiagnostics(); }
}
function closeDiagModal(){
  const overlay = document.getElementById('diagOverlay');
  if(overlay){ overlay.style.display='none'; }
}
document.getElementById('openDiag')?.addEventListener('click', (e)=>{ e.preventDefault(); openDiagModal(); });
document.getElementById('closeDiag')?.addEventListener('click', (e)=>{ e.preventDefault(); closeDiagModal(); });
document.getElementById('rerunDiag')?.addEventListener('click', (e)=>{ e.preventDefault(); runDiagnostics(); });
document.addEventListener('keydown', (e)=>{ if(e.key==='Escape'){ closeDiagModal(); } });

/* ===== Glob√°ln√≠ p≈ôep√≠naƒçe: zobrazit a≈æ po volbƒõ lokace ===== */
function showGlobalTabs(flag){
  const box = document.getElementById('globalModeTabs');
  if(!box) return;
  if(flag){
    // Nastav aktivn√≠ tlaƒç√≠tko podle prvn√≠ho dne (pokud existuje), jinak default 'seeing'
    let mode = 'seeing';
    try{
      const firstId = Object.keys(window._graphMode||{})[0];
      if(firstId && window._graphMode[firstId]) mode = window._graphMode[firstId];
    }catch(e){}
    box.classList.add('shown');
    box.querySelectorAll('.mode-btn').forEach(b=>{
      b.classList.toggle('active', b.getAttribute('data-mode')===mode);
    });
  }else{
    box.classList.remove('shown');
  }
}


/* ===== Global mode change ===== */
function changeAllGraphModes(mode){
  // zv√Ωraznƒõn√≠ glob√°ln√≠ch tlaƒç√≠tek
  document.querySelectorAll('.global-mode-tabs .mode-btn').forEach(b=>{
    b.classList.toggle('active', b.getAttribute('data-mode')===mode);
  });
  // zmƒõna v≈°ech dn≈Ø
  Object.keys(window._graphData).forEach(contentId=>{
    changeGraphMode(contentId, mode);
    // z√°rove≈à zmƒõnit zv√Ωraznƒõn√≠ v ka≈æd√©m dni
    const tabs=document.querySelector(`#${contentId}`).parentElement.querySelector('.mode-tabs');
    if(tabs){
      tabs.querySelectorAll('.mode-btn').forEach(b=>{
        b.classList.toggle('active', b.getAttribute('data-mode')===mode);
      });
    }
  });
}

</script>

<script>
(function(){
  function isSmall(){ return window.matchMedia('(max-width: 768px)').matches; }
  function fixMapMobileHeight(){
    var mapPanel=document.getElementById("mapPanel");
    var mapDiv=document.getElementById("map");
    if(!mapPanel||!mapDiv) return;

    // Mobile: enforce square based on actual available width
    var w = mapPanel.getBoundingClientRect().width;
    if(!w || w <= 0){
      // Fallback: use viewport width minus body padding (approx)
      w = Math.max(280, Math.round(window.innerWidth - 16));
    }
    mapPanel.style.setProperty('height', w + 'px', 'important');
    mapDiv.style.setProperty('height', w + 'px', 'important');

    if(window._leafletMap){ setTimeout(function(){ window._leafletMap.invalidateSize(); }, 100); }
  }
  // Monkey-patch: keep original for desktop; override behavior only on mobile
  var orig = window.syncMapHeight;
  window.syncMapHeight = function(){
    if(isSmall()){
      fixMapMobileHeight();
      return; // skip desktop sync
    }
    if(typeof orig === 'function'){ return orig.apply(this, arguments); }
  };
  // Apply once on load + on orientation change
  window.addEventListener('load', function(){ if(isSmall()) fixMapMobileHeight(); });
  window.addEventListener('orientationchange', function(){ setTimeout(function(){ if(isSmall()) fixMapMobileHeight(); }, 250); });
})();
</script>

<script src="https://cdn.jsdelivr.net/npm/astronomy-engine@2.1.19/astronomy.browser.min.js"></script>
<script>
/* ===== Planet visibility widget (visibleplanets.dev) ===== */
(function(){
  const ICONS = { Mercury:"‚òø", Venus:"‚ôÄ", Earth:"‚äï", Mars:"‚ôÇ", Jupiter:"‚ôÉ", Saturn:"‚ôÑ", Uranus:"‚õ¢", Neptune:"‚ôÜ", Pluto:"‚ôá", Moon:"‚òæ", Sun:"‚òâ" };
  const CONST_GLYPHS = { Aries:"‚ôà", Taurus:"‚ôâ", Gemini:"‚ôä", Cancer:"‚ôã", Leo:"‚ôå", Virgo:"‚ôç", Libra:"‚ôé", Scorpio:"‚ôè", Sagittarius:"‚ôê", Capricorn:"‚ôë", Aquarius:"‚ôí", Pisces:"‚ôì", Capricornus:"‚ôë" };

  const $ = (id)=>document.getElementById(id);

  function clamp(n,a,b){ return Math.max(a, Math.min(b, n)); }
  function fmt(n, digits=1){
    if(n===null || n===undefined || Number.isNaN(Number(n))) return "‚Äî";
    return Number(n).toFixed(digits);
  }
  function altitudeToPct(alt){
    const a = clamp(Number(alt), -90, 90);
    return (a + 90) / 180 * 100;
  }
  function azToCompass(az){
    if(az===null || az===undefined || Number.isNaN(Number(az))) return "‚Äî";
    const dirs = ["N","NE","E","SE","S","SW","W","NW","N"];
    const i = Math.round(Number(az)/45);
    return dirs[clamp(i,0,8)];
  }

  function fmtLocalTimeFromAstroTime(t, offsetSeconds){
    if(!t) return null;
    try{
      const dt = (t.date instanceof Date) ? t.date : (t instanceof Date ? t : null);
      if(!dt) return null;
      const local = new Date(dt.getTime() + (offsetSeconds||0)*1000);
      return local.toLocaleTimeString("cs-CZ",{hour:"2-digit",minute:"2-digit"});
    }catch(e){ return null; }
  }

  function computeRiseSetForBodies(bodies, lat, lon){
    const offsetSeconds = (typeof window.__lastUtcOffsetSeconds === "number") ? window.__lastUtcOffsetSeconds : 0;
    const observer = (window.Astronomy && Astronomy.Observer) ? new Astronomy.Observer(lat, lon, 0) : null;
    if(!observer || !window.Astronomy || !Astronomy.SearchRiseSet){
      return bodies; // library not loaded => keep placeholders
    }

    const now = new Date(); // UTC instant
    const limitDays = 2;    // try to find next events
    bodies.forEach(b=>{
      const bodyName = b.name;
      // visibleplanets returns planet names (Mercury, Venus, Mars, Jupiter, Saturn, Uranus, Neptune) and sometimes others
      try{
        const riseT = Astronomy.SearchRiseSet(bodyName, observer, +1, now, limitDays);
        const setT  = Astronomy.SearchRiseSet(bodyName, observer, -1, now, limitDays);
        b.riseLocal = fmtLocalTimeFromAstroTime(riseT, offsetSeconds) || "‚Äî";
        b.setLocal  = fmtLocalTimeFromAstroTime(setT,  offsetSeconds) || "‚Äî";
      }catch(e){
        b.riseLocal = "‚Äî";
        b.setLocal  = "‚Äî";
      }
    });
    return bodies;
  }
  function qualityChip(alt, mag){
    const a = Number(alt);
    const m = (mag===null || mag===undefined || Number.isNaN(Number(mag))) ? null : Number(mag);
    if(a >= 25 && (m === null || m <= 2.5)) return {cls:"good", text:"dobr√°"};
    if(a >= 10 && (m === null || m <= 4.5)) return {cls:"warn", text:"mo≈æn√°"};
    if(a >= 0) return {cls:"warn", text:"n√≠zko"};
    return {cls:"bad", text:"pod obzorem"};
  }
  function escapeHtml(str){
    return String(str).replace(/[&<>"']/g, (m) => ({ "&":"&amp;","<":"&lt;",">":"&gt;",'"':"&quot;","'":"&#039;" }[m]));
  }
  function getConstGlyph(name){
    if(!name) return "‚ú∂";
    const key = String(name).trim();
    return CONST_GLYPHS[key] || "‚ú∂";
  }

  function makeCard(b){
    const name = b?.name || "‚Äî";
    const icon = ICONS[name] || "ü™ê";
    const alt = Number(b?.altitude);
    const az  = Number(b?.azimuth);
    const mag = (b?.magnitude === null || b?.magnitude === undefined) ? null : Number(b?.magnitude);
    const constel = b?.constellation || "‚Äî";
    const chip = qualityChip(alt, mag);
    const pct = altitudeToPct(alt);
    const rise = b?.riseLocal || null;
    const set  = b?.setLocal  || null;

    const el = document.createElement("div");
    el.className = "pw-card";
    el.innerHTML = `
      <div class="pw-rowTop">
        <div class="pw-planet">
          <div class="pw-icon">${icon}</div>
          <div class="pw-name">
            <strong>${escapeHtml(name)}</strong>
            <span class="pw-const" title="Souhvƒõzd√≠">
              <span aria-hidden="true">${getConstGlyph(constel)}</span>
              <span>${escapeHtml(constel)}</span>
            </span>
          </div>
        </div>
        <div class="pw-chip ${chip.cls}" title="Orientaƒçn√≠ hodnocen√≠ viditelnosti">${chip.text}</div>
      </div>

      <div class="pw-meter" title="Horizont je uprost≈ôed. Vlevo = -90¬∞, vpravo = +90¬∞ (zenit).">
        <div class="tick t1"></div>
        <div class="horizon" title="0¬∞ obzor"></div>
        <div class="tick t2"></div>
        <div class="dot" style="left:${pct}%;"></div>
      </div>

      <div class="pw-meta">
        <div class="pw-kv" title="V√Ω≈°ka nad obzorem">Alt: ${fmt(alt,1)}¬∞</div>
        <div class="pw-kv" title="Azimut (0¬∞=sever, 90¬∞=v√Ωchod)">Az: ${fmt(az,0)}¬∞ ${azToCompass(az)}</div>
        <div class="pw-kv" title="Zd√°nliv√° hvƒõzdn√° velikost (ni≈æ≈°√≠ = jasnƒõj≈°√≠)">Mag: ${mag===null? "‚Äî" : fmt(mag,1)}</div>
      <div class="pw-kv" title="V√Ωchod/Z√°pad (lok√°ln√≠ ƒças vyhledan√©ho m√≠sta)" data-riseset="1">V√Ωchod: ${rise||"‚Äî"} ¬∑ Z√°pad: ${set||"‚Äî"}</div>
      </div>
    `;
    return el;
  }

  let lastAbort = null;

  async function loadPlanets(lat, lon, opts={}){
    const showBelow = !!opts.showBelow;
    const label = opts.label || null;

    if(label && $("pw-observer-label")) $("pw-observer-label").textContent = "Pozorovatel: " + label;

    const url = new URL("https://api.visibleplanets.dev/v3");
    url.searchParams.set("latitude", String(lat));
    url.searchParams.set("longitude", String(lon));
    url.searchParams.set("aboveHorizon", showBelow ? "false" : "true");

    if(lastAbort) lastAbort.abort();
    lastAbort = new AbortController();

    if($("pw-status")) $("pw-status").textContent = "Naƒç√≠t√°m‚Ä¶";
    if($("pw-meta")) $("pw-meta").textContent = "";
    if($("pw-grid")) $("pw-grid").innerHTML = "";

    try{
      const t0 = performance.now();
      const res = await fetch(url.toString(), { signal: lastAbort.signal });
      if(!res.ok) throw new Error("HTTP " + res.status);
      const data = await res.json();
      const t1 = performance.now();

      const bodies = Array.isArray(data?.data) ? data.data : (Array.isArray(data) ? data : []);
      const meta = data?.meta || null;

      const wanted = new Set(["Mercury","Venus","Mars","Jupiter","Saturn","Uranus","Neptune"]);
      const filtered = bodies.filter(b => wanted.has(b?.name));

      if($("pw-status")){
        $("pw-status").textContent = filtered.length ? "Hotovo." : "Nenalezeny ≈æ√°dn√© planety (zkus ‚Äûuk√°zat i pod obzorem‚Äú).";
      }

      computeRiseSetForBodies(filtered, lat, lon);

      filtered.sort((a,b)=> (Number(b.altitude)||-999) - (Number(a.altitude)||-999));
      const frag = document.createDocumentFragment();
      filtered.forEach(b => frag.appendChild(makeCard(b)));
      if($("pw-grid")) $("pw-grid").appendChild(frag);

      const metaParts = [];
      if(meta?.engineVersion) metaParts.push("engine " + meta.engineVersion);
      metaParts.push("API: visibleplanets");
      metaParts.push("Rise/Set: Astronomy Engine");
      metaParts.push("t=" + Math.round(t1 - t0) + "ms");
      if($("pw-meta")) $("pw-meta").textContent = metaParts.join(" ¬∑ ");
    }catch(err){
      if(err?.name === "AbortError") return;
      console.error(err);
      if($("pw-status")) $("pw-status").textContent = "Chyba naƒç√≠t√°n√≠: " + (err?.message || err);
      if($("pw-meta")) $("pw-meta").textContent = "";
    }
  }

  // Public hook for the main page: call this after searching a place
  window.setObserverLocation = function(lat, lon, label){
    if($("pw-observer-label")) $("pw-observer-label").textContent = "Pozorovatel: " + (label || "‚Äî");
    loadPlanets(lat, lon, { showBelow: $("pw-show-below")?.checked, label });
  };

  // UI: toggle below-horizon
  $("pw-show-below")?.addEventListener("change", ()=>{
    // try to reuse last known coords (from astroState if exists)
    let lat = (window.astroState && Number(window.astroState.lat)) || 50.0755;
    let lon = (window.astroState && Number(window.astroState.lon)) || 14.4378;
    if(window.__lastObserverLatLon){
      lat = window.__lastObserverLatLon.lat;
      lon = window.__lastObserverLatLon.lon;
    }
    loadPlanets(lat, lon, { showBelow: $("pw-show-below").checked, label: (labelFromPage()||"‚Äî") });
  });

  function labelFromPage(){
    const np = document.getElementById("nowPlace");
    if(np && np.textContent && np.textContent.trim() !== "‚Äî") return np.textContent.trim();
    const info = document.getElementById("info-name");
    if(info && info.textContent) return info.textContent.trim().split(',')[0] || null;
    return null;
  }

  // Initial default (Praha)
  loadPlanets(50.0755, 14.4378, { showBelow: false, label: "Praha" });
})();
</script>


<!-- ===== API DIAGNOSTIKA ===== -->
<section id="api-diagnostics" style="margin-top:20px">
  </section>

</body>
</html>
